[comment encoding = UTF-8 /]
[module generateSelectMethods('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::util /]
[import be::unamur::polystore::acceleo::main::impl::select::relationshiptype::generateSelectMethodsImpl]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::impl::select::entitytype::generateSimpleSelectFromGivenRelationalTable/]
[import be::unamur::polystore::acceleo::main::impl::select::entitytype::generateSimpleSelectFromGivenDocumentCollection/]
[import be::unamur::polystore::acceleo::main::impl::select::entitytype::generateSelectKeyValue/]


[template public generateSelectMethods(rel : RelationshipType, override: Boolean)]

[comment Role TDO pojo retrieval methods /]

[if (rel.roles -> size() = 2 and rel.attributes->size() = 0)]
[let role1 : Role = rel.roles->any(true)]
[let role2 : Role = role1.getOppositeRoles()->any(true)]

/* Retrieve the Technical Data Object (TDO) for a Role in a mapped reference declared in a specific Abstract Physical Structure. 
	The entity mapped on the right hand side of the reference may be stored in another physical structure than where the ref is declared. 
	Leading to apparent inconsistency in the method name. But it is actually the physical structure of the ref and not the EntityDTO.*/
[for (ref : Reference | role1.getMappedReferences(role1.getMappingRules()))]
[if (isHostedInJoinPhysicalStructureServing(role2, ref.getAbstractPhysicalStructureNotEmbeddedObject()) = false)]
[generateRefRelatedMethods(ref, override, role1, role2)/]
[/if]
[if (isHostedInJoinPhysicalStructureServing(role2, ref.getAbstractPhysicalStructureNotEmbeddedObject()))]
[let ref2 : Reference = getMappedReferenceInSamePhysicalStructureForOppositeRole(role2, ref.getAbstractPhysicalStructureNotEmbeddedObject())]
[generateRefRelatedMethodsInJoinPhysicalStructure(ref, ref2, override, role1, role2)/]
[/let]
[/if]
[/for]
[for (ref : Reference | role2.getMappedReferences(role2.getMappingRules()))]
[if (isHostedInJoinPhysicalStructureServing(role1, ref.getAbstractPhysicalStructureNotEmbeddedObject()) = false)]
[generateRefRelatedMethods(ref, override, role2, role1)/]
[/if]
[if (isHostedInJoinPhysicalStructureServing(role1, ref.getAbstractPhysicalStructureNotEmbeddedObject()))]
[let ref2 : Reference = getMappedReferenceInSamePhysicalStructureForOppositeRole(role1, ref.getAbstractPhysicalStructureNotEmbeddedObject())]
[generateRefRelatedMethodsInJoinPhysicalStructure(ref, ref2, override, role2, role1)/]
[/let]
[/if]
[/for]

[for (embedded : EmbeddedObject | getMappedEmbeddedObjects(role1, role1.getMappingRules()))]
[generateEmbeddedObjectMappedToRoleMethod(role1, embedded, role2, override) /]
[/for]

[/let]
[/let]
[else]
// Not implemented yet
[/if]

[comment Relationship type POJO retrieval methods /]

public [if (override = false)]abstract [/if]java.util.List<pojo.[rel.name.toUpperFirst()/]> get[rel.name.toUpperFirst()/]List([for (role: Role | rel.roles)][if (i > 1)],[/if]
	conditions.Condition<conditions.[role.entity.name.toUpperFirst() /]Attribute> [role.name/]_condition[/for][if (rel.attributes->size() > 0)],
	conditions.Condition<conditions.[rel.name.toUpperFirst() /]Attribute> [rel.name /]_condition
	[/if]
)[if (override = false)];[else][implMethod1(rel) /][/if]

[for (role: Role | rel.roles)]
public java.util.List<pojo.[rel.name.toUpperFirst()/]> get[rel.name.toUpperFirst()/]ListBy[role.name.toUpperFirst() /]Condition(
	conditions.Condition<conditions.[role.entity.name.toUpperFirst()/]Attribute> [role.name/]_condition
){
	return get[rel.name.toUpperFirst() /]List([getListOfNullValues(i - 1) /][if(i - 1 > 0)], [/if][role.name/]_condition[getListOfNullValues(rel.roles->size() -  i, true) /][if (rel.attributes->size() > 0)], null[/if]);
}

public [if (isMaxOne(role) = false)]java.util.List<pojo.[rel.name.toUpperFirst() /]>[else]pojo.[rel.name.toUpperFirst() /][/if] get[rel.name.toUpperFirst() /][if (isMaxOne(role) = false)]List[/if]By[role.name.toUpperFirst() /](pojo.[role.entity.name.toUpperFirst()/] [role.name /]) {
	// TODO using id for selecting
	return null;
}
[/for]
[if (rel.attributes->size() > 0)]

public java.util.List<pojo.[rel.name.toUpperFirst() /]> get[rel.name.toUpperFirst() /]ListBy[rel.name.toUpperFirst() /]Condition(
	conditions.Condition<conditions.[rel.name.toUpperFirst()/]Attribute> [rel.name/]_condition
){
	return get[rel.name.toUpperFirst() /]List([getListOfNullValues(rel.roles->size()) /], [rel.name/]_condition);
}
[/if]
[/template]


[template private generateRefRelatedMethods(ref : Reference, override : Boolean, roleSource : Role, roleTarget : Role)]
[comment left side of reference /]
// Left side '[ref.sourceField->first().getPhysicalName()/]' of reference [ '['/][ref.name/] [ ']'/]
public [if (override = false)]abstract [/if]Dataset<[roleSource.entity.name.toUpperFirst() /]TDO> get[roleSource.entity.name.toUpperFirst()/]TDOList[roleSource.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/](Condition<[roleSource.entity.name.toUpperFirst()/]Attribute> condition)[if (override = false)];[else]{	
[comment TODO Implemented multi composed ref. Currently Apply only to single attribute reference /]
[let dbs : Set(Database) = ref.sourceField->first().getAbstractPhysicalStructureNotEmbeddedObject().getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))]
[if (dbs->size() = 0)]
return null;
[else]
	MutableBoolean refilterFlag = new MutableBoolean(false);
[let db : Database = dbs->any(true)]
[if (db.dbType = pml::DatabaseType::MARIADB or db.dbType = pml::DatabaseType::SQLITE)]
[comment TODO change here if needed to handle multi composed refrences/]
[generateSimpleSelectFromGivenRelationalTable(roleSource.entity, ref.getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.sourceField}})/]
[/if]
[if (db.dbType = pml::DatabaseType::MONGODB)] 
[generateSimpleSelectFromGivenDocumentCollection(roleSource.entity, ref.sourceField->any(true).getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.sourceField}}) /]
[/if]
[if (db.dbType = pml::DatabaseType::REDIS)]
[generateSelectKeyValue(roleSource.entity, ref.sourceField->any(true).getAbstractPhysicalStructureNotEmbeddedObject().oclAsType(pml::KeyValuePair), db, Sequence{Sequence{ref, ref.sourceField}})/]
[/if]
[/let]
[/if]
[/let]		
}[/if]


// Right side '[ref.targetField->first().getPhysicalName()/]' of reference [ '['/][ref.name/] [ ']'/]
[comment right side of reference /]
[comment TODO Apply only to single attribute reference /]
public [if (override = false)]abstract [/if]Dataset<[roleTarget.entity.name.toUpperFirst() /]TDO> get[roleTarget.entity.name.toUpperFirst()/]TDOList[roleTarget.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/](Condition<[roleTarget.entity.name.toUpperFirst()/]Attribute> condition)[if (override = false)];[else]{
[let dbs : Set(Database) = ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject().getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))]
[if (dbs->size() = 0)]
return null;
[else]
[let db : Database = dbs->any(true)]
	MutableBoolean refilterFlag = new MutableBoolean(false);
[if (db.dbType = pml::DatabaseType::MARIADB or db.dbType = pml::DatabaseType::SQLITE)]
[generateSimpleSelectFromGivenRelationalTable(roleTarget.entity, ref.targetField->any(true).getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.targetField}})/][/if]
[if (db.dbType = pml::DatabaseType::MONGODB)] 
[generateSimpleSelectFromGivenDocumentCollection(roleTarget.entity, ref.targetField->any(true).getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.targetField}}) /]
[/if]
[if (db.dbType = pml::DatabaseType::REDIS)]
[generateSelectKeyValue(roleTarget.entity, ref.targetField->any(true).getAbstractPhysicalStructureNotEmbeddedObject().oclAsType(pml::KeyValuePair), db, Sequence{Sequence{ref, ref.targetField}})/]
[/if]
[/let]
[/if]
[/let]	
}[/if]
[/template]

[template private generateRefRelatedMethodsInJoinPhysicalStructure(ref : Reference, ref2 : Reference, override : Boolean, roleSource : Role, roleTarget : Role)]
[comment left side of reference /]
//join structure
// Left side '[ref.sourceField->first().getPhysicalName()/]' of reference [ '['/][ref.name/] [ ']'/]
public [if (override = false)]abstract [/if]Dataset<[roleSource.entity.name.toUpperFirst() /]TDO> get[roleSource.entity.name.toUpperFirst()/]TDOList[roleSource.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.targetField->first().getPhysicalSchema().name.toUpperFirst()/](Condition<[roleSource.entity.name.toUpperFirst()/]Attribute> condition)[if (override = false)];[else]{	
[comment TODO Implemented multi composed ref. Currently Apply only to single attribute reference /]
[let dbs : Set(Database) = ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject().getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))]
[if (dbs->size() = 0)]
return null;
[else]
	MutableBoolean refilterFlag = new MutableBoolean(false);
[let db : Database = dbs->any(true)]
[if (db.dbType = pml::DatabaseType::MARIADB or db.dbType = pml::DatabaseType::SQLITE)]
[comment TODO change here if needed to handle multi composed refrences/]
[generateSimpleSelectFromGivenRelationalTable(roleSource.entity, ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.targetField}})/]
[/if]
[if (db.dbType = pml::DatabaseType::MONGODB)] 
[generateSimpleSelectFromGivenDocumentCollection(roleSource.entity, ref.targetField->any(true).getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.targetField}}) /]
[/if]
[if (db.dbType = pml::DatabaseType::REDIS)]
[generateSelectKeyValue(roleSource.entity, ref.targetField->any(true).getAbstractPhysicalStructureNotEmbeddedObject().oclAsType(pml::KeyValuePair), db, Sequence{Sequence{ref, ref.targetField}})/]
[/if]
[/let]
[/if]
[/let]		
}[/if]

// return join values
public [if (override = false)]abstract [/if]Dataset<[roleSource.ancestors(RelationshipType)->any(true).name.toUpperFirst() /]TDO> get[roleSource.ancestors(RelationshipType)->any(true).name.toUpperFirst()/]TDOListIn[roleSource.ancestors(pml::RelationshipType)->any(true).name.toUpperFirst()/]_[ref.name.toUpperFirst()/]_[ref2.name.toUpperFirst()/]In[ref.sourceField->first().getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.sourceField->first().getPhysicalSchema().name.toUpperFirst()/]()[if (override = false)];[else]{	
[comment TODO Implemented multi composed ref. Currently Apply only to single attribute reference /]
	Condition condition = null;
[let dbs : Set(Database) = ref.sourceField->first().getAbstractPhysicalStructureNotEmbeddedObject().getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))]
[if (dbs->size() = 0)]
return null;
[else]
	MutableBoolean refilterFlag = new MutableBoolean(false);
[let db : Database = dbs->any(true)]
[if (db.dbType = pml::DatabaseType::MARIADB or db.dbType = pml::DatabaseType::SQLITE)]
[comment TODO change here if needed to handle multi composed refrences/]
[generateSimpleSelectFromGivenRelationalTable(roleSource.ancestors(RelationshipType)->any(true), ref.sourceField->first().getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.sourceField}, Sequence{ref2, ref2.sourceField}})/]
[/if]
[if (db.dbType = pml::DatabaseType::MONGODB)] 
[generateSimpleSelectFromGivenDocumentCollection(roleSource.ancestors(RelationshipType)->any(true), ref.sourceField->any(true).getAbstractPhysicalStructureNotEmbeddedObject(), db, Sequence{Sequence{ref, ref.sourceField}, Sequence{ref2, ref2.sourceField}}) /]
[/if]
[if (db.dbType = pml::DatabaseType::REDIS)]
[generateSelectKeyValue(roleSource.ancestors(RelationshipType)->any(true), ref.sourceField->any(true).getAbstractPhysicalStructureNotEmbeddedObject().oclAsType(pml::KeyValuePair), db, Sequence{Sequence{ref, ref.sourceField}, Sequence{ref2, ref2.sourceField}})/]
[/if]
[/let]
[/if]
[/let]		
}[/if]

[if (ref.name < ref2.name)][comment this weird condition only makes sure that the generated method is not generated twice/]
[let struct : AbstractPhysicalStructure = ref.sourceField->first().getAbstractPhysicalStructureNotEmbeddedObject()]
[let dbs : Set(Database) = struct.getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))]
[let rel : RelationshipType = roleSource.ancestors(RelationshipType)->any(true)]
[for (db : Database | dbs)]
[if (override = true and (db.dbType = pml::DatabaseType::MARIADB or db.dbType = pml::DatabaseType::SQLITE))][generateGetSQLWhereClauseMethod(rel, struct, db)/][/if]
[if (override = true and db.dbType = pml::DatabaseType::MONGODB) ][generateBSONMatchQueryMethod(rel, struct, db) /][/if]
[if (override = true and db.dbType = pml::DatabaseType::REDIS) ]//TODO redis[/if]
[/for]
[/let]
[/let]
[/let]
[/if]


[/template]

[template private generateEmbeddedObjectMappedToRoleMethod(role : Role, embedded : EmbeddedObject, opposite : Role, override : Boolean)]
// method accessing the embedded object [embedded.name/] mapped to role [role.name /]
public [if (override = false)]abstract [/if]Dataset<pojo.[role.getRelationShipType().name.toUpperFirst() /]> get[role.getRelationShipType().name.toUpperFirst()/]ListIn[ getPhysicalFieldAbsolutePath(embedded) /](Condition<[role.entity.name.toUpperFirst()/]Attribute> [role.name /]_condition, Condition<[opposite.entity.name.toUpperFirst()/]Attribute> [opposite.name /]_condition)[if (override = false)];[else]{	
[let dbs : Set(Database) = embedded.getAbstractPhysicalStructureNotEmbeddedObject().getConcernedDatabases(embedded.ancestors(Domainmodel)->any(true))]
[if (dbs->size() = 0)]
	return null;
[else]
	MutableBoolean refilterFlag = new MutableBoolean(false);
[let db : Database = dbs->any(true)]
[if (db.dbType = pml::DatabaseType::MONGODB)] 
	[generateSelectFromGivenHybridDocumentCollection(role.ancestors(RelationshipType)->any(true), embedded.getAbstractPhysicalStructureNotEmbeddedObject(), db) /]
[/if]
[/let]
[/if]
[/let]		
}[/if]
[/template]