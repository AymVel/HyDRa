[comment encoding = UTF-8 /]
[module generateSimpleSelectMethodsImpl('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::generateJavaDataType /]
[import be::unamur::polystore::acceleo::main::util /]

[comment get{E}List({E)AttributeCondition /]

[template public generateSimpleSelectMethodsImpl(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	List<Dataset<[entityType.name.toUpperFirst() /]>> datasets = new ArrayList<Dataset<[entityType.name.toUpperFirst() /]>>();
	Dataset<[entityType.name.toUpperFirst()/]> d = null;
	[for (struct: AbstractPhysicalStructure | getConcernedPhysicalStructures(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	d = get[entityType.name.toUpperFirst() /]ListIn[struct.name/]From[db.name.toUpperFirst() /](condition);
	if(d != null)
		datasets.add(d);
	[/for]
	[/for]
	
	if(datasets.size() == 0)
		return null;

	d = datasets.get(0);
	if(datasets.size() == 1)
		return d;

	
	[if (entityType.identifier.oclIsUndefined() = false and entityType.identifier.attributes-> size() > 0)]
	List<String> idFields = new ArrayList<String>();
	[for (attr : Attribute | entityType.identifier.attributes)]
	idFields.add("[attr.name /]");
	[/for]
	scala.collection.Seq<String> seq = scala.collection.JavaConverters.asScalaIteratorConverter(idFields.iterator()).asScala().toSeq();
	Dataset<Row> res = d.join(datasets.get(1)
[for (attr : Attribute | entityType.attributes)][if (entityType.identifier.attributes->includes(attr) = false)]
						.withColumnRenamed("[attr.name.toLowerFirst() /]", "[attr.name.toLowerFirst() /]_1")
[/if][/for]						, seq, "fullouter");
	for(int i = 2; i < datasets.size(); i++) {
		res = res.join(datasets.get(i)
[for (attr : Attribute | entityType.attributes)][if (entityType.identifier.attributes->includes(attr) = false)]
						.withColumnRenamed("[attr.name.toLowerFirst() /]", "[attr.name.toLowerFirst() /]_" + i)
[/if][/for]						, seq, "fullouter");
	} 
	d = res.map((MapFunction<Row, [entityType.name.toUpperFirst() /]>) r -> {
			[entityType.name.toUpperFirst() /] [entityType.name.toLowerFirst() /]_res = new [entityType.name.toUpperFirst() /]();
			[for (attr : Attribute | entityType.attributes)]
			
			// attribute '[entityType.name.toUpperFirst() /].[attr.name.toLowerFirst() /]'
			[generateJavaType(attr.type) /] firstNotNull_[attr.name /] = r.getAs("[attr.name.toLowerFirst() /]");
			[if (entityType.identifier.attributes->includes(attr) = false)]
			for (int i = 1; i < datasets.size(); i++) {
				[generateJavaType(attr.type) /] [attr.name.toLowerFirst() /]2 = r.getAs("[attr.name.toLowerFirst() /]_" + i);
				if (firstNotNull_[attr.name /] != null && [attr.name.toLowerFirst() /]2 != null && !firstNotNull_[attr.name/].equals([attr.name.toLowerFirst() /]2)) {
					// TODO logger
					System.out.println("data consistency problem: duplicate values for attribute : '[entityType.name.toUpperFirst() /].[attr.name.toLowerFirst() /]' ==> " + firstNotNull_[attr.name /] + " and " + [attr.name.toLowerFirst() /]2);
				}
				if (firstNotNull_[attr.name /] == null && [attr.name.toLowerFirst() /]2 != null) {
					firstNotNull_[attr.name /] = [attr.name.toLowerFirst() /]2;
				}
			}
			[/if]
			[entityType.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst() /](firstNotNull_[attr.name /]);
			[/for]
			return [entityType.name.toLowerFirst() /]_res;
		}, Encoders.bean([entityType.name.toUpperFirst() /].class));
	return d;
	[else]
	for(int i = 1; i < datasets.size(); i++)
		d = d.union(datasets.get(i));
	return d;
	[/if]
	
}[/template]


[comment List<Customer> getCustomerListInCustomerFromMyMariabDB(Condition) /]

[template public generateSimpleSelectFromGivenDatabase(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]{
[if (db.dbType = pml::DatabaseType::MARIADB or db.dbType = pml::DatabaseType::SQLITE)]
[generateSimpleSQLSelectFromGivenDatabase(ent, struct, db) /]
[else]return null;
[/if]	
	
}[/template]

[template public generateGetSQLWhereClauseMethod(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
private static Pair<String, List<String>> getSQLWhereClauseIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[ent.name.toUpperFirst() /]Attribute> condition) {
	String where = null;	
	List<String> preparedValues = new java.util.ArrayList<String>();
	if(condition != null) {
		
		if(condition instanceof SimpleCondition) {
			[ent.name /]Attribute attr = ((SimpleCondition<[ent.name /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[ent.name /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[ent.name /]Attribute>) condition).getValue();
			if(value != null) {
				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [ent.name.toUpperFirst() /]Attribute.[attr.name /] ) {
					String valueString = Util.transformSQLValue(value);
					String sqlOp = op.getSQLOperator();
					[if (field.ancestors(LongField) -> size() = 0)]
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "%" + Util.escapeReservedCharSQL(valueString)  + "%";
					}
					[else]
					String preparedValue = [getSQLPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false) /];
					Boolean like_op = false;
					if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getSQLPatternLikeSymbol() /]")) {
						like_op = true;
						sqlOp = "LIKE";
						preparedValue = [getSQLPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), true) /];
					} else {
						if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getSQLPatternLikeSymbol() /]")) {
							sqlOp = "NOT LIKE";
							like_op = true;
							preparedValue = [getSQLPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), true) /];
						}
					}
					if(op == Operator.CONTAINS && valueString != null) {
						like_op = true;
						preparedValue = [getSQLPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), true) /];
						preparedValue = preparedValue.replaceAll("[getSQLPatternValue() /]", "%[getSQLPatternValue() /]%");
					}
					
					if(like_op)
						valueString = Util.escapeReservedCharSQL(valueString);
					preparedValue = preparedValue.replaceAll("[getSQLPatternValue() /]", valueString).replaceAll("[getSQLPatternLikeSymbol() /]", "%");
					[/if]
					
					where = "[getPhysicalName(field)/] " + sqlOp + " ?";
					preparedValues.add(preparedValue);
				}
				[/if]
				[/let]
				[/for]
			}
		}

		if(condition instanceof AndCondition) {
			Pair<String, List<String>> pairLeft = getSQLWhereClauseIn[struct.name.toUpperFirst() /]From[db.name.toUpperFirst() /](((AndCondition) condition).getLeftCondition());
			Pair<String, List<String>> pairRight = getSQLWhereClauseIn[struct.name.toUpperFirst() /]From[db.name.toUpperFirst() /](((AndCondition) condition).getRightCondition());
			String whereLeft = pairLeft.getKey();
			String whereRight = pairRight.getKey();
			List<String> leftValues = pairLeft.getValue();
			List<String> rightValues = pairRight.getValue();
			if(whereLeft != null || whereRight != null) {
				if(whereLeft == null)
					where = whereRight;
				else
					if(whereRight == null)
						where = whereLeft;
					else
						where = "(" + whereLeft + " AND " + whereRight + ")";
				preparedValues.addAll(leftValues);
				preparedValues.addAll(rightValues);
			}
		}

		if(condition instanceof OrCondition) {
			Pair<String, List<String>> pairLeft = getSQLWhereClauseIn[struct.name.toUpperFirst() /]From[db.name.toUpperFirst() /](((OrCondition) condition).getLeftCondition());
			Pair<String, List<String>> pairRight = getSQLWhereClauseIn[struct.name.toUpperFirst() /]From[db.name.toUpperFirst() /](((OrCondition) condition).getRightCondition());
			String whereLeft = pairLeft.getKey();
			String whereRight = pairRight.getKey();
			List<String> leftValues = pairLeft.getValue();
			List<String> rightValues = pairRight.getValue();
			if(whereLeft != null || whereRight != null) {
				if(whereLeft == null)
					where = whereRight;
				else
					if(whereRight == null)
						where = whereLeft;
					else
						where = "(" + whereLeft + " OR " + whereRight + ")";
				preparedValues.addAll(leftValues);
				preparedValues.addAll(rightValues);
			}
		}

	}

	return new ImmutablePair<String, List<String>>(where, preparedValues);
}
[/template]

[template public generateSimpleSQLSelectFromGivenDatabase(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
[comment  select * from Client where (...) /]
	Pair<String, List<String>> whereClause = getSQLWhereClauseIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](condition);
	String where = whereClause.getKey();
	List<String> preparedValues = whereClause.getValue();
	for(String preparedValue : preparedValues) {
		where = where.replaceFirst("\\?", "'" + Util.escapeQuote(preparedValue) + "'");
	}
	
	Dataset<Row> d = dbconnection.SparkConnectionMgr.getDataset("[db.name /]", "[struct.name/]");
	if(where != null) {
		d = d.where(where);
	}

	Dataset<[ent.name.toUpperFirst() /]> res = d.map((MapFunction<Row, [ent.name.toUpperFirst() /]>) r -> {
				[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /]_res = new [ent.name.toUpperFirst() /]();
				Integer groupIndex = null;
				String regex = null;
				String value = null;
				Pattern p = null;
				Matcher m = null;
				boolean matches = false;
				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				
				// attribute [ '[' /][ent.name.toUpperFirst() /].[attr.name.toUpperFirst() /][ ']' /]
				[if (field.ancestors(LongField) -> size() = 0)]
				[comment shortField or bracketfield/]
				[generateJavaType(attr.type)/] [attr.name.toLowerFirst()/] = r.getAs("[attr.name /]");
				[ent.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([attr.name.toLowerFirst()/]);
				[else]
				[comment LongField /]
				regex = "[getJavaRegexFromLongField(field.ancestors(LongField) -> first().oclAsType(LongField)) /]";
				groupIndex = [getPositionInLongField(field, field.ancestors(LongField) -> first().oclAsType(LongField))/];
				if(groupIndex == null) {
					throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				value = r.getAs("[field.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
				p = Pattern.compile(regex);
				m = p.matcher(value);
				matches = m.find();
				String [attr.name.toLowerFirst()/] = null;
				if(matches) {
					[attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
				} else {
					throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				[ent.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
				[/if]
				[/if]
				[/let]
				[/for]

				return [ent.name.toLowerFirst() /]_res;
			}, Encoders.bean([ent.name.toUpperFirst() /].class));


	return res;
[/template]



