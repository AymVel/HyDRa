[comment encoding = UTF-8 /]
[module generateSimpleSelectFromGivenDocumentCollection('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::generateJavaDataType /]
[import be::unamur::polystore::acceleo::main::util /]

[comment get{E}List({E)AttributeCondition /]

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
	String bsonQuery = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](condition);
	if(bsonQuery != null) {
		bsonQuery = "{$match: {" + bsonQuery + "}}";	
	} 
	
	Dataset<Row> dataset = SparkConnectionMgr.getSparkSessionForMongoDB("[db.name /]", "[struct.name /]", bsonQuery);
	dataset.printSchema();


	Dataset<[ent.name.toUpperFirst() /]> res = dataset.flatMap((FlatMapFunction<Row, [ent.name.toUpperFirst() /]>) r -> {
			List<[ent.name.toUpperFirst() /]> list_res = new ArrayList<[ent.name.toUpperFirst() /]>();
			Integer groupIndex = null;
			String regex = null;
			String value = null;
			Pattern p = null;
			Matcher m = null;
			boolean matches = false;
			Row nestedRow = null;

			boolean addedInList = false;
			Row r1 = r;
			[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /]1 = new [ent.name.toUpperFirst() /]();

			[generateFlatMapBody(struct, ent, db, 1)/]
			
			return list_res.iterator();

	}, Encoders.kryo([ent.name.toUpperFirst() /].class));




	res = dataset.map((MapFunction<Row, [ent.name.toUpperFirst() /]>) r -> {
				[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /]_res = new [ent.name.toUpperFirst() /]();
				Integer groupIndex = null;
				String regex = null;
				String value = null;
				Pattern p = null;
				Matcher m = null;
				boolean matches = false;
				Row nestedRow = null;
				WrappedArray array = null;
				boolean stop;

				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
				// attribute [ '[' /][ent.name.toUpperFirst() /].[attr.name.toUpperFirst() /][ ']' /]
				nestedRow =  r;
				stop = false;
				[if (ancestorsList->size() > 0)]
				[comment EmbeddedObject as ancestor /]
				[for (anc : EmbeddedObject | ancestorsList->reverse())]
				[if (anc.cardinality = pml::Cardinality::ONE or anc.cardinality = pml::Cardinality::ZERO_ONE)]
				[comment simple row /]
				if(!stop)
					nestedRow = (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
				[else]
				[comment array /]
				if(!stop) {
					array = (WrappedArray) nestedRow.getAs("[getPhysicalName(anc)/]");
					if(array.size() > 0) {
						/**
						We only retrieve the first document from the array.
						Unfortunately, in the case where the first document contains only null data,
						but the second document contains not null data, the consequence will be that
						the conceptual attribute will be affected to value null 
						(while it could have been affected to non-null value contained in the second one)
						TODO Perhaps we could consider the FIRST NOT-NULL document, 
						but it would complicate the ACCELEO algorithm
						**/
						nestedRow = (Row) array.apply(0);
					}
					else
						stop = true;
				}
				[/if]
				[/for]
				[/if]
				
				if(!stop) {
					[if (field.ancestors(LongField) -> size() = 0)]
					[comment shortField or bracketfield/]
					[generateJavaType(attr.type)/] [attr.name.toLowerFirst()/] = nestedRow.getAs("[getPhysicalName(field) /]");
					[ent.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([attr.name.toLowerFirst()/]);
					[else]
					[comment LongField /]
					regex = "[getJavaRegexFromLongField(field.ancestors(LongField) -> first().oclAsType(LongField)) /]";
					groupIndex = [getPositionInLongField(field, field.ancestors(LongField) -> first().oclAsType(LongField))/];
					if(groupIndex == null) {
						throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					}
					value = nestedRow.getAs("[field.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
					p = Pattern.compile(regex);
					m = p.matcher(value);
					matches = m.find();
					String [attr.name.toLowerFirst()/] = null;
					if(matches) {
						[attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
					} else {
						throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					}
					[ent.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
					[/if]
				}
				[/let]
				[/if]
				[/let]
				[/for]
				
				return [ent.name.toLowerFirst() /]_res;
			}, Encoders.kryo([ent.name.toUpperFirst() /].class));


	return res;
[/template]

[template public generateBSONMatchQueryMethod(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
private static String getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[ent.name.toUpperFirst() /]Attribute> condition) {	
	String res = null;	
	if(condition != null) {
		if(condition instanceof SimpleCondition) {
			[ent.name /]Attribute attr = ((SimpleCondition<[ent.name /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[ent.name /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[ent.name /]Attribute>) condition).getValue();
			if(value != null) {
				String valueString = Util.transformBSONValue(value);
				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [ent.name.toUpperFirst() /]Attribute.[attr.name /] ) {
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
				[if (field.ancestors(LongField) -> size() > 0)]
				String preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, false) /];
				boolean like_op = false;
				boolean not_like = false; 
				if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
					//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
				} else {
					if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
						//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
						not_like = true;
						like_op = true;
						preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					}
				}
				if(op == Operator.CONTAINS && valueString != null) {
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					preparedValue = preparedValue.replaceAll("[getPatternValue() /]", ".*[getPatternValue() /].*");
				}
					
				if(like_op)
					valueString = Util.escapeReservedRegexMongo(valueString);
				preparedValue = preparedValue.replaceAll("[getPatternValue() /]", valueString).replaceAll("[getPatternOtherValue() /]", ".*");
				
				if(valueString.equals(preparedValue)) // 5 <=> 5, the preparedValue is the same type as the original value
					preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
				else // 5 => 5*, the preparedValue became a string
					preparedValue = Util.getDelimitedMongoValue(String.class, preparedValue);
					

				String mongoOp = (like_op) ? "$regex" : op.getMongoDBOperator();
				//if not_like = true then we need to complement/negate the given regex
				res = "[getPhysicalName(field)/]': {" + (!not_like ? (mongoOp + ": " + preparedValue) : ("$not: {" + mongoOp + ": " + preparedValue + "}")) + "}";
				[else]
					String mongoOp = op.getMongoDBOperator();
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "'.*" + Util.escapeReservedRegexMongo(valueString)  + ".*'";
					} else {
						preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
					}
					res = "[getPhysicalName(field) /]': {" + mongoOp + ": " + preparedValue + "}";
				[/if]

				[if (ancestorsList->size() > 0)]
				[comment level-n field, with n > 1 /]
				[for (ancestor : EmbeddedObject | ancestorsList)]
					res = "[ancestor.name /]." + res;
				[/for]
				[/if]
				res = "'" + res;
				[/let]
				}
				[/if]
				[/let]
				[/for]
			}
		}

		if(condition instanceof AndCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition());
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition());			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $and: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";
		}

		if(condition instanceof OrCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getLeftCondition());
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getRightCondition());			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $or: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";	
		}

		

		
	}

	return res;
}
[/template]

[template private generateFlatMapBody(arg : OclAny, ent : EntityType, db : Database, level : Integer)]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributes(child, ent, ent.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]

Row nestedRow = ...

[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
nestedRow =  r[level /];
[comment EmbeddedObject as ancestor /]
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[if (anc.cardinality = pml::Cardinality::ONE or anc.cardinality = pml::Cardinality::ZERO_ONE)]
[comment simple row /]
nestedRow = (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/if]
[/for]
[/let]

[if (child.ancestors(LongField) -> size() = 0)]
[comment shortField or bracketfield/]
[ent.name.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](([generateJavaType(attr.type)/]) nestedRow.getAs("[getPhysicalName(child) /]"));
toAdd[level/] = true;					
[else]
[comment LongField /]
regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
if(groupIndex == null) {
	throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
}
value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
p = Pattern.compile(regex);
m = p.matcher(value);
matches = m.find();
if(matches) {
	String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
	[ent.name.toLowerFirst() /][level/].set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
	toAdd[level/] = true;
} else {
	throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
}
[/if]










[/for]
[/if]
[/let]
[/for]
[let children : Collection(EmbeddedObject) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg, ent, ent.ancestors(Domainmodel)->first().mappingRules)]
[if (children->size() > 0)]
[for (child : EmbeddedObject | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
	Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
	[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /][level + 1/] = [ent.name.toLowerFirst() /][level/].clone();
	[generateFlatMapBody(child, ent, db, level + 1)/]
}

if(toAdd[level /]) {
	list_res.add(product[level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /]) {
	list_res.add(product[level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/template]

[query private getChildrenNonArrayPhysicalFields(arg : OclAny) : Collection(PhysicalField) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getChildrenNonArrayPhysicalFields(java.lang.Object)', Sequence{arg})
/]

[query private getMappedAttributes(field: PhysicalField, ent: EntityType, rules: MappingRules) : Collection(Attribute) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getMappedAttributes(be.unamur.polystore.pml.PhysicalField, be.unamur.polystore.pml.EntityType, be.unamur.polystore.pml.MappingRules)', Sequence{field, ent, rules})
/]

[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg : OclAny, ent: EntityType, rules: MappingRules) : Collection(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(java.lang.Object, be.unamur.polystore.pml.EntityType, be.unamur.polystore.pml.MappingRules)', Sequence{arg, ent, rules})
/]


