[comment encoding = UTF-8 /]
[module generateSimpleSelectFromGivenDocumentCollection('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::generateJavaDataType /]
[import be::unamur::polystore::acceleo::main::util /]

[comment get{E}List({E)AttributeCondition /]

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
	String bsonQuery = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](condition);
	if(bsonQuery != null) {
		bsonQuery = "{$match: {" + bsonQuery + "}}";	
	} 
	
	Dataset<Row> dataset = SparkConnectionMgr.getSparkSessionForMongoDB("[db.name /]", "[struct.name /]", bsonQuery);
	dataset.printSchema();
	Dataset<[ent.name.toUpperFirst() /]> res = dataset.map((MapFunction<Row, [ent.name.toUpperFirst() /]>) r -> {
				[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /]_res = new [ent.name.toUpperFirst() /]();
				Integer groupIndex = null;
				String regex = null;
				String value = null;
				Pattern p = null;
				Matcher m = null;
				boolean matches = false;
				Row r2 = null;
				WrappedArray array = null;
				boolean stop;

				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				[if (ancestorsList->size() = 0)]
				// attribute [ '[' /][ent.name.toUpperFirst() /].[attr.name.toUpperFirst() /][ ']' /]
				[if (field.ancestors(LongField) -> size() = 0)]
				[comment shortField or bracketfield/]
				[generateJavaType(attr.type)/] [attr.name.toLowerFirst()/] = r.getAs("[getPhysicalName(field) /]");
				[ent.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([attr.name.toLowerFirst()/]);
				[else]
				[comment LongField /]
				regex = "[getJavaRegexFromLongField(field.ancestors(LongField) -> first().oclAsType(LongField)) /]";
				groupIndex = [getPositionInLongField(field, field.ancestors(LongField) -> first().oclAsType(LongField))/];
				if(groupIndex == null) {
					throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				value = r.getAs("[field.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
				p = Pattern.compile(regex);
				m = p.matcher(value);
				matches = m.find();
				String [attr.name.toLowerFirst()/] = null;
				if(matches) {
					[attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
				} else {
					throw new Exception("Cannot retrieve value for [ent.name /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				[ent.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
				[/if]
				[else]

				// attribute [ '[' /][ent.name.toUpperFirst() /].[attr.name.toUpperFirst() /][ ']' /]
				[comment EmbeddedObject as ancestor /]
				r2 = r;
				stop = false; [comment /]
				[for (anc : EmbeddedObject | ancestorsList->reverse())]
				[if (anc.cardinality = pml::Cardinality::ONE or anc.cardinality = pml::Cardinality::ZERO_ONE)]
				[comment simple row /]
				if(!stop)
					r2 = (Row) r2.getAs("[getPhysicalName(anc)/]");
				[else]
				[comment array /]
				if(!stop) {
					array = (WrappedArray) r2.getAs("[getPhysicalName(anc)/]");
					if(array.size() > 0) {
						/**
						We only retrieve the first document from the array.
						Unfortunately, in the case where the first document contains only null data,
						but the second document contains not null data, the consequence will be that
						the conceptual attribute will be affected to value null 
						(while it could have been affected to non-null value contained in the second one)
						**/
						r2 = (Row) array.apply(0);
					}
					else
						stop = true;
				}
				[/if]
				[/for]
				
				r2.getAs("[getPhysicalName(field) /]");
				
				[/if]
				[/let]
				[/if]
				[/let]
				[/for]
				
				return [ent.name.toLowerFirst() /]_res;
			}, Encoders.kryo([ent.name.toUpperFirst() /].class));


	return res;
[/template]

[template public generateBSONMatchQueryMethod(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
private static String getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[ent.name.toUpperFirst() /]Attribute> condition) {	
	String res = null;	
	if(condition != null) {
		if(condition instanceof SimpleCondition) {
			[ent.name /]Attribute attr = ((SimpleCondition<[ent.name /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[ent.name /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[ent.name /]Attribute>) condition).getValue();
			if(value != null) {
				String valueString = Util.transformBSONValue(value);
				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [ent.name.toUpperFirst() /]Attribute.[attr.name /] ) {
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
				[if (field.ancestors(LongField) -> size() > 0)]
				String preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, false) /];
				boolean like_op = false;
				boolean not_like = false; 
				if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
					//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
				} else {
					if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
						//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
						not_like = true;
						like_op = true;
						preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					}
				}
				if(op == Operator.CONTAINS && valueString != null) {
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					preparedValue = preparedValue.replaceAll("[getPatternValue() /]", ".*[getPatternValue() /].*");
				}
					
				if(like_op)
					valueString = Util.escapeReservedRegexMongo(valueString);
				preparedValue = preparedValue.replaceAll("[getPatternValue() /]", valueString).replaceAll("[getPatternOtherValue() /]", ".*");
				
				if(valueString.equals(preparedValue)) // 5 <=> 5, the preparedValue is the same type as the original value
					preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
				else // 5 => 5*, the preparedValue became a string
					preparedValue = Util.getDelimitedMongoValue(String.class, preparedValue);
					

				String mongoOp = (like_op) ? "$regex" : op.getMongoDBOperator();
				//if not_like = true then we need to complement/negate the given regex
				res = "[getPhysicalName(field)/]': {" + (!not_like ? (mongoOp + ": " + preparedValue) : ("$not: {" + mongoOp + ": " + preparedValue + "}")) + "}";
				[else]
					String mongoOp = op.getMongoDBOperator();
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "'.*" + Util.escapeReservedRegexMongo(valueString)  + ".*'";
					} else {
						preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
					}
					res = "[getPhysicalName(field) /]': {" + mongoOp + ": " + preparedValue + "}";
				[/if]

				[if (ancestorsList->size() > 0)]
				[comment level-n field, with n > 1 /]
				[for (ancestor : EmbeddedObject | ancestorsList)]
					res = "[ancestor.name /]." + res;
				[/for]
				[/if]
				res = "'" + res;
				[/let]
				}
				[/if]
				[/let]
				[/for]
			}
		}

		if(condition instanceof AndCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition());
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition());			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $and: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";
		}

		if(condition instanceof OrCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getLeftCondition());
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getRightCondition());			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $or: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";	
		}

		

		
	}

	return res;
}
[/template]

