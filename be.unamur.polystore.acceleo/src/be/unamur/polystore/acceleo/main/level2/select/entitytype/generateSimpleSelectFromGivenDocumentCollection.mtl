[comment encoding = UTF-8 /]
[module generateSimpleSelectFromGivenDocumentCollection('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::generateJavaDataType /]
[import be::unamur::polystore::acceleo::main::util /]

[comment get{E}List({E)AttributeCondition /]

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
	String bsonQuery = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](condition, refilterFlag);
	if(bsonQuery != null) {
		bsonQuery = "{$match: {" + bsonQuery + "}}";	
	} 
	
	Dataset<Row> dataset = SparkConnectionMgr.getSparkSessionForMongoDB("[db.name /]", "[struct.name /]", bsonQuery);

	Dataset<[ent.name.toUpperFirst() /]> res = dataset.flatMap((FlatMapFunction<Row, [ent.name.toUpperFirst() /]>) r -> {
			List<[ent.name.toUpperFirst() /]> list_res = new ArrayList<[ent.name.toUpperFirst() /]>();
			Integer groupIndex = null;
			String regex = null;
			String value = null;
			Pattern p = null;
			Matcher m = null;
			boolean matches = false;
			Row nestedRow = null;

			boolean addedInList = false;
			Row r1 = r;
			[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /]1 = new [ent.name.toUpperFirst() /]();

			[generateFlatMapBody(struct, ent, db, 1)/]
			
			return list_res.iterator();

	}, Encoders.bean([ent.name.toUpperFirst() /].class));

	return res;
[/template]

[template public generateBSONMatchQueryMethod(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
private static String getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[ent.name.toUpperFirst() /]Attribute> condition, MutableBoolean refilterFlag) {	
	String res = null;	
	if(condition != null) {
		if(condition instanceof SimpleCondition) {
			[ent.name /]Attribute attr = ((SimpleCondition<[ent.name /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[ent.name /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[ent.name /]Attribute>) condition).getValue();
			if(value != null) {
				String valueString = Util.transformBSONValue(value);
				boolean isConditionAttrEncountered = false;

				[for (attr : Attribute | ent.attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, ent.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [ent.name.toUpperFirst() /]Attribute.[attr.name /] ) {
					isConditionAttrEncountered = true;
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
				[if (field.ancestors(LongField) -> size() > 0)]
				String preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, false) /];
				boolean like_op = false;
				boolean not_like = false; 
				if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
					//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
				} else {
					if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
						//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
						not_like = true;
						like_op = true;
						preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					}
				}
				if(op == Operator.CONTAINS && valueString != null) {
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					preparedValue = preparedValue.replaceAll("[getPatternValue() /]", ".*[getPatternValue() /].*");
				}
					
				if(like_op)
					valueString = Util.escapeReservedRegexMongo(valueString);
				preparedValue = preparedValue.replaceAll("[getPatternValue() /]", valueString).replaceAll("[getPatternOtherValue() /]", ".*");
				
				if(valueString.equals(preparedValue)) // 5 <=> 5, the preparedValue is the same type as the original value
					preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
				else // 5 => 5*, the preparedValue became a string
					preparedValue = Util.getDelimitedMongoValue(String.class, preparedValue);
					

				String mongoOp = (like_op) ? "$regex" : op.getMongoDBOperator();
				//if not_like = true then we need to complement/negate the given regex
				res = "[getPhysicalName(field)/]': {" + (!not_like ? (mongoOp + ": " + preparedValue) : ("$not: {" + mongoOp + ": " + preparedValue + "}")) + "}";
				[else]
					String mongoOp = op.getMongoDBOperator();
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "'.*" + Util.escapeReservedRegexMongo(valueString)  + ".*'";
					} else {
						preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
					}
					res = "[getPhysicalName(field) /]': {" + mongoOp + ": " + preparedValue + "}";
				[/if]

				[if (ancestorsList->size() > 0)]
				[comment level-n field, with n > 1 /]
				[for (ancestor : EmbeddedObject | ancestorsList)]
					res = "[ancestor.name /]." + res;
				[/for]
				[/if]
				res = "'" + res;
				[/let]
				}
				[/if]
				[/let]
				[/for]
				if(!isConditionAttrEncountered) {
					refilterFlag.setValue(true);
					res = "$expr: {$eq:[ '[' /]1,1[ ']' /]}";
				}
				
			}
		}

		if(condition instanceof AndCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition(), refilterFlag);
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition(), refilterFlag);			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $and: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";
		}

		if(condition instanceof OrCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getLeftCondition(), refilterFlag);
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getRightCondition(), refilterFlag);			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $or: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";	
		}

		

		
	}

	return res;
}
[/template]

[template private generateFlatMapBody(arg : OclAny, ent : EntityType, db : Database, level : Integer)]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributes(child, ent, ent.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [ent.name /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	[ent.name.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](([generateJavaType(attr.type)/]) nestedRow.getAs("[getPhysicalName(child) /]"));
	toAdd[level/] = true;					
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	[ent.name.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](([generateJavaType(attr.type)/]) nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]"));
	toAdd[level/] = true;	
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [ent.name /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[ent.name.toLowerFirst() /][level/].set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [ent.name /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/for]
[/if]
[/let]
[/for]
[let children : Collection(EmbeddedObject) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg, ent, ent.ancestors(Domainmodel)->first().mappingRules)]
[if (children->size() > 0)]
[for (child : EmbeddedObject | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[ent.name.toUpperFirst() /] [ent.name.toLowerFirst() /][level + 1/] = ([ent.name.toUpperFirst() /]) [ent.name.toLowerFirst() /][level/].clone();
		[generateFlatMapBody(child, ent, db, level + 1)/]
	}
}

if(toAdd[level /]) {
	[if (level > 1)]if(condition == null || condition.evaluate([ent.name.toLowerFirst() /][level /]))[/if]
		list_res.add([ent.name.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /]) {
	[if (level > 1)]if(condition ==null || condition.evaluate([ent.name.toLowerFirst() /][level /]))[/if]
	list_res.add([ent.name.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/template]

[query private getChildrenNonArrayPhysicalFields(arg : OclAny) : Collection(PhysicalField) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getChildrenNonArrayPhysicalFields(java.lang.Object)', Sequence{arg})
/]

[query private getMappedAttributes(field: PhysicalField, ent: EntityType, rules: MappingRules) : Collection(Attribute) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getMappedAttributes(be.unamur.polystore.pml.PhysicalField, be.unamur.polystore.pml.EntityType, be.unamur.polystore.pml.MappingRules)', Sequence{field, ent, rules})
/]

[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg : OclAny, ent: EntityType, rules: MappingRules) : Collection(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(java.lang.Object, be.unamur.polystore.pml.EntityType, be.unamur.polystore.pml.MappingRules)', Sequence{arg, ent, rules})
/]

[query private getSequenceOfNonArrayEmbeddedObjects(field : OclAny) : Sequence(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.services.Util', 'getSequenceOfNonArrayEmbeddedObjects(org.eclipse.emf.ecore.EObject)', Sequence{field})
/]



