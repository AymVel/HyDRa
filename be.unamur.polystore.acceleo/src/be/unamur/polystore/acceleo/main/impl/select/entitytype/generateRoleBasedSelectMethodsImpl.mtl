[comment encoding = UTF-8 /]
[module generateRoleBasedSelectMethodsImpl('http://www.unamur.be/polystore/Pml')]

[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]


[template public generateRoleBasedSelectMethodsImpl(entity: EntityType, role: Role, conceptualSchema: ConceptualSchema)]{
	[comment getAListInREL /]
	[if (role.getRelationShipType().roles -> size() = 2)]
	MutableBoolean [role.name/]_refilter = new MutableBoolean(false);
	List<Dataset<[entity.name.toUpperFirst() /]>> datasetsPOJO = new ArrayList<Dataset<[entity.name.toUpperFirst() /]>>();
	[let role2 : Role = getOppositeRoles(role)->any(true)]
	Dataset<[role2.entity.name.toUpperFirst()/]> all = null;
	boolean all_already_persisted = false;
	MutableBoolean [role2.name/]_refilter;
	org.apache.spark.sql.Column joinCondition = null;
		[for (ref: Reference | getMappedReferences(role, conceptualSchema.getMappingRules()))]
			[if (hasMappedReferenceInSamePhysicalStructureForOppoisteRole(role2, ref.getAbstractPhysicalStructureNotEmbeddedObject()))]
				[let ref2 : Reference = getMappedReferenceInSamePhysicalStructureForOppositeRole(role2, ref.getAbstractPhysicalStructureNotEmbeddedObject())]
	// join physical structure A<-AB->B
	[comment  
	// role et role2 sont dans la même structure => join table
	// A <- AB -> B  /]
	[generateCodeForJoinPhysicalStructure(entity, role, ref, role2, ref2)/]
				[/let]
			[/if]
			[if (hasMappedReferenceInSamePhysicalStructureForOppoisteRole(role2, ref.getAbstractPhysicalStructureNotEmbeddedObject()) = false)]
	[comment // A -> B /] 
	[comment  // Il n'existe pas de ref2 mappé à Role2 qui soit dans la même structure que Ref. -> Pas de table de jointure /]
				[let struct1 : AbstractPhysicalStructure = ref.getAbstractPhysicalStructureNotEmbeddedObject()]
				[let struct2 : AbstractPhysicalStructure = ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject()]
				[let db1 : Database = struct1.getConcernedDatabases(struct1.ancestors(Domainmodel)->first())->any(true)]
				[let db2 : Database = struct2.getConcernedDatabases(struct2.ancestors(Domainmodel)->first())->any(true)]
				[if (db1 = db2 and db1.dbType.isRelational())]
	[comment A & B same db, so we are able to get both objects with one SQL. No need for TDO objects. Use of RelPOJO /]
	// For role '[role.name/]' in reference '[ref.name/]'. A->B Scenario in SQL DB
	[role2.name/]_refilter = new MutableBoolean(false);
	Dataset<[role.getRelationShipType().name.toUpperFirst()/]> res_[ref.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role.name.toUpperFirst()/]And[role.getOppositeRoles()->any(true).name.toUpperFirst()/]ListIn[ref.name.toUpperFirst()/]In[struct1.name.toUpperFirst()/]From[db1.name.toUpperFirst()/]([role.getRelationShipType().roles->first().name/]_condition, [role.getRelationShipType().roles->first().getOppositeRoles()->any(true).name/]_condition, [role.name/]_refilter, [role2.name/]_refilter);
	Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = null;
	[comment  Refilter function needed if the condition on B is based on an attribute of B present only in another structure containing B/]
	if([role2.name/]_refilter.booleanValue()) {
		if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
		joinCondition = null;
					[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
						[for (attr : Attribute | role2.entity.identifier.attributes)]
							[if (i = 1)]
		joinCondition = res_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
							[else]
		joinCondition = joinCondition.and(res_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
							[/if]
						[/for]
					[/if]
		if(joinCondition == null)
			res_[entity.name/]_[ref.name/] = res_[ref.name/].join(all).select("[role.name/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
		else
			res_[entity.name/]_[ref.name/] = res_[ref.name/].join(all, joinCondition).select("[role.name/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
	} else
		res_[entity.name/]_[ref.name/] = res_[ref.name/].map((MapFunction<[role.getRelationShipType().name.toUpperFirst()/],[entity.name.toUpperFirst()/]>) r -> r.get[role.name.toUpperFirst()/](), Encoders.bean([entity.name.toUpperFirst()/].class));
				[else]
	[comment A & B not in same DB or involve NoSQL struct. So need of TDO objects /]
	// For role '[role.name/]' in reference '[ref.name/]'. A->B Scenario
	[role2.name/]_refilter = new MutableBoolean(false);
	Dataset<[entity.name.toUpperFirst()/]TDO> [entity.name.toLowerFirst()/]TDO[ref.name/][role.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[entity.name.toUpperFirst()/]TDOList[role.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/]([role.name/]_condition, [role.name/]_refilter);
	Dataset<[role2.entity.name.toUpperFirst()/]TDO> [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role2.entity.name.toUpperFirst()/]TDOList[role2.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/]([role2.name/]_condition, [role2.name/]_refilter);
	if([role2.name/]_refilter.booleanValue()) {
		if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
		joinCondition = null;
					[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
						[for (attr : Attribute | role2.entity.identifier.attributes)]
							[if (i = 1)]
		joinCondition = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
							[else]
		joinCondition = joinCondition.and([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
							[/if]
						[/for]
					[/if]
		if(joinCondition == null)
			[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].as("A").join(all).select("A.*").as(Encoders.bean([role2.entity.name.toUpperFirst()/]TDO.class));
		else
			[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].as("A").join(all, joinCondition).select("A.*").as(Encoders.bean([role2.entity.name.toUpperFirst()/]TDO.class));
	}

	
	Dataset<Row> res_[ref.name/] = [entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].join([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/]
					[for (attr : Attribute | role2.entity.attributes)]
			.withColumnRenamed("[attr.name.toLowerFirst() /]", "[role2.entity.name/]_[attr.name.toLowerFirst() /]")
					[/for]
			.withColumnRenamed("logEvents", "[role2.entity.name/]_logEvents"),
			[if (ref.sourceField->any(true).oclIsTypeOf(ArrayField)  or ref.sourceField.ancestors(EmbeddedObject)->size() > 0 or (ref.sourceField->any(true).ancestors(KVComplexField)->size() > 0 and ref.sourceField->any(true).ancestors(KVComplexField)->any(true).type=KVDataType::LIST))]
			// Multi valued reference
			functions.array_contains([entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.sourceField->first().getPhysicalName()/]"),[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.targetField->first().getPhysicalName()/]")));
			[else]
			[entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.sourceField->first().getPhysicalName()/]").equalTo([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[getJavaAbsolutePath(ref).toLowerFirst().toLowerFirst() /]_[ref.targetField->first().getPhysicalName()/]")));
			[/if]
	Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = res_[ref.name/].select([for (attr : Attribute | entity.attributes)] "[attr.name/]",[/for] "logEvents").as(Encoders.bean([entity.name.toUpperFirst()/].class));
	
				[/if]
	[comment A->B . The join will return as many lines as B. But we return A, so duplicates may exist. /]
	[if (entity.identifier.oclIsUndefined() = true)]
	logger.warn("Conceptual entity '[entity.name/]' does not have a declared identifier. Returned results may be inconsistent.");
	res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/].dropDuplicates();
	[else]
	res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/].dropDuplicates(new String[ '[' /][ ']' /] {[if (entity.identifier.oclIsUndefined() = false)][for (attr : Attribute | entity.identifier.attributes) separator(',')]"[attr.name/]"[/for][/if]});
	[/if]
	datasetsPOJO.add(res_[entity.name/]_[ref.name/]);
				[/let]
				[/let]
				[/let]
				[/let]
			[/if]
		[/for]
	
		[for (ref: Reference | getMappedReferences(role2, conceptualSchema.getMappingRules()))]
			[if (hasMappedReferenceInSamePhysicalStructureForOppoisteRole(role, ref.getAbstractPhysicalStructureNotEmbeddedObject()) = false)]
	[comment B -> A /]
	[comment reference mapped to a conceptual role. /]
	[comment optimization possible when the 2 physical structures to join are stored in the same database (ex: a SQL join is possible instead of a brute-force Spark join /]
				[let struct1 : AbstractPhysicalStructure = ref.getAbstractPhysicalStructureNotEmbeddedObject()]
				[let struct2 : AbstractPhysicalStructure = ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject()]
				[let db1 : Database = struct1.getConcernedDatabases(struct1.ancestors(Domainmodel)->first())->any(true)]
				[let db2 : Database = struct2.getConcernedDatabases(struct2.ancestors(Domainmodel)->first())->any(true)]
	[role2.name/]_refilter = new MutableBoolean(false);
				[if (db1 = db2 and db1.dbType.isRelational())]
	// For role '[role2.name/]' in reference '[ref.name/]'  B->A Scenario in SQL Db.
	Dataset<[role.getRelationShipType().name.toUpperFirst()/]> res_[ref.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role.getOppositeRoles()->any(true).name.toUpperFirst()/]And[role.name.toUpperFirst()/]ListIn[ref.name.toUpperFirst()/]In[struct1.name.toUpperFirst()/]From[db1.name.toUpperFirst()/]([role.getRelationShipType().roles->first().name/]_condition, [role.getRelationShipType().roles->first().getOppositeRoles()->any(true).name/]_condition, [role.getRelationShipType().roles->first().name/]_refilter, [role.getRelationShipType().roles->first().getOppositeRoles()->any(true).name/]_refilter);
	Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = null;
	if([role2.name/]_refilter.booleanValue()) {
		if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
		joinCondition = null;
					[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
						[for (attr : Attribute | role2.entity.identifier.attributes)]
							[if (i = 1)]
		joinCondition = res_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
							[else]
		joinCondition = joinCondition.and(res_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
							[/if]
						[/for]
					[/if]
		if(joinCondition == null)
			res_[entity.name/]_[ref.name/] = res_[ref.name/].join(all).select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
		else
			res_[entity.name/]_[ref.name/] = res_[ref.name/].join(all, joinCondition).select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
	} else
		res_[entity.name/]_[ref.name/] = res_[ref.name/].map((MapFunction<[role.getRelationShipType().name.toUpperFirst()/],[entity.name.toUpperFirst()/]>) r -> r.get[role.name.toUpperFirst()/](), Encoders.bean([entity.name.toUpperFirst()/].class));
				[else]
	[comment A & B not in same DB or involve NoSQL struct. So need of TDO objects /]
	// For role '[role2.name/]' in reference '[ref.name/]'  B->A Scenario
	Dataset<[role2.entity.name.toUpperFirst()/]TDO> [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role2.entity.name.toUpperFirst()/]TDOList[role2.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/]([role2.name/]_condition, [role2.name/]_refilter);
	Dataset<[entity.name.toUpperFirst()/]TDO> [entity.name.toLowerFirst()/]TDO[ref.name/][role.name /] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[entity.name.toUpperFirst()/]TDOList[role.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/]([role.name/]_condition, [role.name/]_refilter);
	if([role2.name/]_refilter.booleanValue()) {
		if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
		joinCondition = null;
					[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
						[for (attr : Attribute | role2.entity.identifier.attributes)]
							[if (i = 1)]
		joinCondition = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
							[else]
		joinCondition = joinCondition.and([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
							[/if]
						[/for]
					[/if]
		if(joinCondition == null)
			[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].as("A").join(all).select("A.*").as(Encoders.bean([role2.entity.name.toUpperFirst()/]TDO.class));
		else
			[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].as("A").join(all, joinCondition).select("A.*").as(Encoders.bean([role2.entity.name.toUpperFirst()/]TDO.class));
	}
			[if (ref.sourceField->any(true).oclIsTypeOf(ArrayField) or ref.sourceField.ancestors(EmbeddedObject)->size() > 0 or (ref.sourceField->any(true).ancestors(KVComplexField)->size()>0 and ref.sourceField->any(true).ancestors(KVComplexField)->any(true).type=KVDataType::LIST))]
	// Multi valued reference
	Dataset<Row> res_[ref.name/] = 
		[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/]
		[for (attr : Attribute | role2.entity.attributes)]
		.withColumnRenamed("[attr.name.toLowerFirst() /]", "[role2.entity.name/]_[attr.name.toLowerFirst() /]")
		[/for]
		.withColumnRenamed("logEvents", "[role2.entity.name/]_logEvents")
		.join([entity.name.toLowerFirst()/]TDO[ref.name/][role.name /],
			functions.array_contains([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.sourceField->first().getPhysicalName()/]"),[entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.targetField->first().getPhysicalName()/]")));
			[else]
	Dataset<Row> res_[ref.name/] = 
		[entity.name.toLowerFirst()/]TDO[ref.name/][role.name /].join([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/]
			[for (attr : Attribute | role2.entity.attributes)]
			.withColumnRenamed("[attr.name.toLowerFirst() /]", "[role2.entity.name/]_[attr.name.toLowerFirst() /]")
			[/for]
			.withColumnRenamed("logEvents", "[role2.entity.name/]_logEvents"),
			[entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.targetField->first().getPhysicalName()/]").equalTo([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.sourceField->first().getPhysicalName()/]")));
			[/if]
	Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = res_[ref.name/].select([for (attr : Attribute | entity.attributes)] "[attr.name/]",[/for] "logEvents").as(Encoders.bean([entity.name.toUpperFirst()/].class));
				[/if]
				[if (entity.identifier.oclIsUndefined() = true)]
	logger.warn("Conceptual entity '[entity.name/]' does not have a declared identifier. Returned results may be inconsistent.");
	res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/].dropDuplicates();
				[else]
	res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/].dropDuplicates(new String[ '[' /][ ']' /] {[if (entity.identifier.oclIsUndefined() = false)][for (attr : Attribute | entity.identifier.attributes) separator(',')]"[attr.name/]"[/for][/if]});
				[/if]
	datasetsPOJO.add(res_[entity.name/]_[ref.name/]);
				[/let]
				[/let]
				[/let]
				[/let]
			[/if]
		[/for]
	
		[let rel : RelationshipType = role.getRelationShipType()]
	Dataset<[rel.name.toUpperFirst()/]> res_[rel.name/]_[role.name/];
	Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/];
	[comment A(B) embedded B in A, getAbyB /]
		[for (embedded : EmbeddedObject | getMappedEmbeddedObjects(role, conceptualSchema.getMappingRules()))]
	// Role '[role.name/]' mapped to EmbeddedObject '[embedded.getPhysicalName()/]' - '[role2.entity.name/]' containing '[entity.name/]'
	[role2.name/]_refilter = new MutableBoolean(false);
	res_[rel.name/]_[role.name/] = [rel.name.toLowerFirst()/]Service.get[rel.name.toUpperFirst()/]ListIn[ getPhysicalFieldAbsolutePath(embedded) /]([role.name/]_condition, [role2.name/]_condition, [role.name/]_refilter, [role2.name/]_refilter);
	if([role2.name/]_refilter.booleanValue()) {
		if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
		joinCondition = null;
			[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
				[for (attr : Attribute | role2.entity.identifier.attributes)]
					[if (i = 1)]
		joinCondition = res_[rel.name/]_[role.name/].col("[role2.name.toLowerFirst()/].[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
					[else]
		joinCondition = joinCondition.and(res_[rel.name/]_[role.name.toLowerFirst()/].col("[role2.name.toLowerFirst()/].[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
					[/if]
				[/for]
			[/if]
		if(joinCondition == null)
			res_[entity.name/] = res_[rel.name/]_[role.name/].join(all).select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
		else
			res_[entity.name/] = res_[rel.name/]_[role.name/].join(all, joinCondition).select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
	
	} else
		res_[entity.name/] = res_[rel.name/]_[role.name/].map((MapFunction<[rel.name.toUpperFirst()/],[entity.name.toUpperFirst()/]>) r -> r.get[role.name.toUpperFirst()/](), Encoders.bean([entity.name.toUpperFirst()/].class));
			[if (entity.identifier.oclIsUndefined() = true)]
	logger.warn("Conceptual entity '[entity.name/]' does not have a declared identifier. Returned results may be inconsistent.");
	res_[entity.name/] = res_[entity.name/].dropDuplicates();
			[else]
	res_[entity.name/] = res_[entity.name/].dropDuplicates(new String[ '[' /][ ']' /] {[if (entity.identifier.oclIsUndefined() = false)][for (attr : Attribute | entity.identifier.attributes) separator(',')]"[attr.name/]"[/for][/if]});
			[/if]
	datasetsPOJO.add(res_[entity.name/]);
		[/for]
	[comment for method getContainedObject by role/]
	[comment B(A) embedded A in B, getAbyB /]
		[for (embedded : EmbeddedObject | getMappedEmbeddedObjects(role2, conceptualSchema.getMappingRules()))]
	// Role '[role2.name/]' mapped to EmbeddedObject '[embedded.getPhysicalName()/]' '[entity.name/]' containing '[role2.entity.name/]' 
	[role2.name/]_refilter = new MutableBoolean(false);
	res_[rel.name/]_[role.name/] = [rel.name.toLowerFirst()/]Service.get[rel.name.toUpperFirst()/]ListIn[ getPhysicalFieldAbsolutePath(embedded) /]([role2.name/]_condition, [role.name/]_condition, [role2.name/]_refilter, [role.name/]_refilter);
	if([role2.name/]_refilter.booleanValue()) {
		if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
		joinCondition = null;
			[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
				[for (attr : Attribute | role2.entity.identifier.attributes)]
					[if (i = 1)]
		joinCondition = res_[rel.name/]_[role.name/].col("[role2.name.toLowerFirst()/].[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
					[else]
		joinCondition = joinCondition.and(res_[rel.name/]_[role.name.toLowerFirst()/].col("[role2.name.toLowerFirst()/].[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
					[/if]
				[/for]
			[/if]
		if(joinCondition == null)
			res_[entity.name/] = res_[rel.name/]_[role.name/].join(all).select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
		else
			res_[entity.name/] = res_[rel.name/]_[role.name/].join(all, joinCondition).select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
	
	} else
		res_[entity.name/] = res_[rel.name/]_[role.name/].map((MapFunction<[rel.name.toUpperFirst()/],[entity.name.toUpperFirst()/]>) r -> r.get[role.name.toUpperFirst()/](), Encoders.bean([entity.name.toUpperFirst()/].class));
			[if (entity.identifier.oclIsUndefined() = true)]
	logger.warn("Conceptual entity '[entity.name/]' does not have a declared identifier. Returned results may be inconsistent.");
			res_[entity.name/] = res_[entity.name/].dropDuplicates();
			[else]
	res_[entity.name/] = res_[entity.name/].dropDuplicates(new String[ '[' /][ ']' /] {[if (entity.identifier.oclIsUndefined() = false)][for (attr : Attribute | entity.identifier.attributes) separator(',')]"[attr.name/]"[/for][/if]});
			[/if]
	datasetsPOJO.add(res_[entity.name/]);
		[/for]
		[/let]
	
	
	//Join datasets or return 
	Dataset<[entity.name.toUpperFirst()/]> res = fullOuterJoins[entity.name.toUpperFirst()/](datasetsPOJO);
	if(res == null)
		return null;

	[comment  If A is in another structure not involved in A-r-B , it may contain other attributes of A.
		We therefore get those A objects, and we left join them with the to return A dataset. (So we retrieve the complete A attributes)/]
		[let structures : Set(AbstractPhysicalStructure) = getMappedStructuresNotConcernedByRelationshipType(entity, role.getRelationShipType(), conceptualSchema.getMappingRules())]
		[if (structures->size() > 0)]
	List<Dataset<[entity.name.toUpperFirst()/]>> lonely[entity.name/]List = new ArrayList<Dataset<[entity.name.toUpperFirst()/]>>();
			[for (struct : AbstractPhysicalStructure | structures)]
	lonely[entity.name/]List.add(get[entity.name.toUpperFirst()/]ListIn[struct.name.toUpperFirst()/]From[getConcernedDatabases(struct, struct.ancestors(Domainmodel)->first())->any(true).name.toUpperFirst()/]([role.name/]_condition, new MutableBoolean(false)));
			[/for]
	[comment  If A1 'standalone' and A2 standalone. We need to fullouter them./]
	Dataset<[entity.name.toUpperFirst()/]> lonely[entity.name.toUpperFirst()/] = fullOuterJoins[entity.name.toUpperFirst()/](lonely[entity.name/]List);
	if(lonely[entity.name.toUpperFirst()/] != null) {
		[comment  We left join A & the result of full outer of A1 & A2/]
		res = fullLeftOuterJoins[entity.name.toUpperFirst()/](Arrays.asList(res, lonely[entity.name.toUpperFirst()/]));
	}
		[/if]
		[/let]
	if([role.name/]_refilter.booleanValue())
		res = res.filter((FilterFunction<[entity.name.toUpperFirst() /]>) r -> [role.name/]_condition == null || [role.name/]_condition.evaluate(r));
	

	return res;
	[/let]
	[else]
	// Not implemented yet for > 2 roles
	return null;
	[/if]
	}
[/template]

[template public generateOuterJoinsMethods(entityType : EntityType)]

public static Dataset<[entityType.name.toUpperFirst()/]> fullOuterJoins[entityType.name.toUpperFirst()/](List<Dataset<[entityType.name.toUpperFirst()/]>> datasetsPOJO) {
	return fullOuterJoins[entityType.name.toUpperFirst()/](datasetsPOJO, "fullouter");
}

protected static Dataset<[entityType.name.toUpperFirst()/]> fullLeftOuterJoins[entityType.name.toUpperFirst()/](List<Dataset<[entityType.name.toUpperFirst()/]>> datasetsPOJO) {
	return fullOuterJoins[entityType.name.toUpperFirst()/](datasetsPOJO, "leftouter");
}

private static Dataset<[entityType.name.toUpperFirst()/]> fullOuterJoins[entityType.name.toUpperFirst()/](List<Dataset<[entityType.name.toUpperFirst()/]>> datasetsPOJO, String joinMode) {
	if(datasetsPOJO.size() == 0)
			return null;
	if(datasetsPOJO.size() == 1)
		return datasetsPOJO.get(0);
	Dataset<[entityType.name.toUpperFirst()/]> d = datasetsPOJO.get(0);
	[if (entityType.identifier.oclIsUndefined() = false and entityType.identifier.attributes-> size() > 0)]
		List<String> idFields = new ArrayList<String>();
		[for (attr : Attribute | entityType.identifier.attributes)]
		idFields.add("[attr.name /]");
		[/for]
		logger.debug("Start {} of ['['/]{}[']'/] datasets of ['['/][entityType.name.toUpperFirst()/][']'/] objects",joinMode,datasetsPOJO.size());
		scala.collection.Seq<String> seq = scala.collection.JavaConverters.asScalaIteratorConverter(idFields.iterator()).asScala().toSeq();
		Dataset<Row> res = d.join(datasetsPOJO.get(1)
	[for (attr : Attribute | entityType.attributes)][if (entityType.identifier.attributes->includes(attr) = false)]
							.withColumnRenamed("[attr.name.toLowerFirst() /]", "[attr.name.toLowerFirst() /]_1")
	[/if][/for]						
							.withColumnRenamed("logEvents", "logEvents_1")
						, seq, joinMode);
		for(int i = 2; i < datasetsPOJO.size(); i++) {
			res = res.join(datasetsPOJO.get(i)
	[for (attr : Attribute | entityType.attributes)][if (entityType.identifier.attributes->includes(attr) = false)]
							.withColumnRenamed("[attr.name.toLowerFirst() /]", "[attr.name.toLowerFirst() /]_" + i)
	[/if][/for]	
							.withColumnRenamed("logEvents", "logEvents_" + i)
					, seq, joinMode);
		}
		logger.debug("End join. Start");
		logger.debug("Start transforming Row objects to ['['/][entityType.name.toUpperFirst()/][']'/] objects"); 
		d = res.map((MapFunction<Row, [entityType.name.toUpperFirst() /]>) r -> {
				[entityType.name.toUpperFirst() /] [entityType.name.toLowerFirst() /]_res = new [entityType.name.toUpperFirst() /]();
				[for (attr : Attribute | entityType.attributes)]
				
				// attribute '[entityType.name.toUpperFirst() /].[attr.name.toLowerFirst() /]'
				[generateJavaType(attr.type) /] firstNotNull_[attr.name /] = Util.get[generateJavaType(attr.type) /]Value(r.getAs("[attr.name.toLowerFirst() /]"));
				[if (entityType.identifier.attributes->includes(attr) = false)]
				for (int i = 1; i < datasetsPOJO.size(); i++) {
					[generateJavaType(attr.type) /] [attr.name.toLowerFirst() /]2 = Util.get[generateJavaType(attr.type) /]Value(r.getAs("[attr.name.toLowerFirst() /]_" + i));
					if (firstNotNull_[attr.name /] != null && [attr.name.toLowerFirst() /]2 != null && !firstNotNull_[attr.name/].equals([attr.name.toLowerFirst() /]2)) {
						[entityType.name.toLowerFirst() /]_res.addLogEvent("Data consistency problem for ['['/][entityType.name.toUpperFirst() /] - id :"[if (entityType.identifier.oclIsUndefined() = false)]+[for (attr : Attribute | entityType.identifier.attributes) separator('+')][entityType.name.toLowerFirst() /]_res.get[attr.name.toUpperFirst()/]()[/for][/if]+"[']'/]: different values found for attribute '[entityType.name.toUpperFirst() /].[attr.name.toLowerFirst() /]': " + firstNotNull_[attr.name /] + " and " + [attr.name.toLowerFirst() /]2 + "." );
						logger.warn("Data consistency problem for ['['/][entityType.name.toUpperFirst() /] - id :"[if (entityType.identifier.oclIsUndefined() = false)]+[for (attr : Attribute | entityType.identifier.attributes) separator('+')][entityType.name.toLowerFirst() /]_res.get[attr.name.toUpperFirst()/]()[/for][/if]+"[']'/]: different values found for attribute '[entityType.name.toUpperFirst() /].[attr.name.toLowerFirst() /]': " + firstNotNull_[attr.name /] + " and " + [attr.name.toLowerFirst() /]2 + "." );
					}
					if (firstNotNull_[attr.name /] == null && [attr.name.toLowerFirst() /]2 != null) {
						firstNotNull_[attr.name /] = [attr.name.toLowerFirst() /]2;
					}
				}
				[/if]
				[entityType.name.toLowerFirst() /]_res.set[attr.name.toUpperFirst() /](firstNotNull_[attr.name /]);
				[/for]

				WrappedArray logEvents = r.getAs("logEvents");
				if(logEvents != null)
					for (int i = 0; i < logEvents.size(); i++){
						[entityType.name.toLowerFirst() /]_res.addLogEvent((String) logEvents.apply(i));
					}
	
				for (int i = 1; i < datasetsPOJO.size(); i++) {
					logEvents = r.getAs("logEvents_" + i);
					if(logEvents != null)
					for (int j = 0; j < logEvents.size(); j++){
						[entityType.name.toLowerFirst() /]_res.addLogEvent((String) logEvents.apply(j));
					}
				}

				return [entityType.name.toLowerFirst() /]_res;
			}, Encoders.bean([entityType.name.toUpperFirst() /].class));
		return d;
		[else]
		for(int i = 1; i < datasetsPOJO.size(); i++)
			d = d.union(datasetsPOJO.get(i));
		return d;
		[/if]
}
[/template]

[template private generateCodeForJoinPhysicalStructure(entity: EntityType, role: Role, ref: Reference, role2 : Role, ref2: Reference)]

[let table : AbstractPhysicalStructure = ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject() ]
[let table2 : AbstractPhysicalStructure = ref2.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject() ]
[let jointable : AbstractPhysicalStructure = ref2.getAbstractPhysicalStructureNotEmbeddedObject() ]
[let db1 : Database = table.getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))->any(true)]
[let db2 : Database = table2.getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))->any(true)]
[let joindb : Database = jointable.getConcernedDatabases(ref.ancestors(Domainmodel)->any(true))->any(true)]
[if (db1 = db2 and db2 = joindb and db1.dbType.isRelational() )]
//join between 3 SQL tables stored in same db
// (A AB B)
[role2.name/]_refilter = new MutableBoolean(false);
MutableBoolean [role.getRelationShipType().name/]_refilter = new MutableBoolean(false);
Dataset<[role.getRelationShipType().name.toUpperFirst()/]> res_[entity.name/]_[ref.name/]_[ref2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role.getRelationShipType().name.toUpperFirst()/]ListIn[table.name/]And[jointable.name/]And[table2.name/]From[db1.name/]([role.name/]_condition, [role2.name/]_condition[if(role.getRelationShipType().attributes->size()>0)], [role.getRelationShipType().name/]_condition[/if], [role.name/]_refilter, [role2.name/]_refilter[if(role.getRelationShipType().attributes->size()>0)], [role.getRelationShipType().name/]_refilter[/if]);
Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = null;

if([role2.name/]_refilter.booleanValue()) {
	if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
	joinCondition = null;
	[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
	[for (attr : Attribute | role2.entity.identifier.attributes)]
	[if (i = 1)]
		joinCondition = res_[entity.name/]_[ref.name/]_[ref2.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and(res_[entity.name/]_[ref.name/]_[ref2.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[/if]
		if(joinCondition == null)
			res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/]_[ref2.name/].join(all).select("[role.name/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
		else
			res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/]_[ref2.name/].join(all, joinCondition).select("[role.name/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
} else
	res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/]_[ref2.name/].map((MapFunction<[role.getRelationShipType().name.toUpperFirst()/],[entity.name.toUpperFirst()/]>) r -> r.get[role.name.toUpperFirst()/](), Encoders.bean([entity.name.toUpperFirst()/].class));
	
[elseif (db1 = joindb and db1.dbType.isRelational())]
//join between 2 SQL tables and a non-relational structure
// (A - AB) (B)
[role2.name/]_refilter = new MutableBoolean(false);
MutableBoolean [role.getRelationShipType().name/]_refilter = new MutableBoolean(false);
Dataset<[role.getRelationShipType().name.toUpperFirst()/]TDO> res_[role.getRelationShipType().name/]_[ref.name/]_[ref2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role.getRelationShipType().name.toUpperFirst()/]TDOListIn[table.name/]And[jointable.name/]From[db1.name/]([role.name/]_condition[if(role.getRelationShipType().attributes->size()>0)], [role.getRelationShipType().name/]_condition[/if], [role.name/]_refilter[if(role.getRelationShipType().attributes->size()>0)], [role.getRelationShipType().name/]_refilter[/if]);
Dataset<[role2.entity.name.toUpperFirst()/]TDO> res_[ref2.name/]_[ref.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role2.entity.name.toUpperFirst()/]TDOList[role2.name.toUpperFirst()/]In[ref2.name.toUpperFirst()/]In[table2.name.toUpperFirst()/]From[table2.getPhysicalSchema().name.toUpperFirst()/]([role2.name/]_condition, [role2.name/]_refilter);
if([role2.name/]_refilter.booleanValue()) {
	if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
	joinCondition = null;
	[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
	[for (attr : Attribute | role2.entity.identifier.attributes)]
	[if (i = 1)]
		joinCondition = res_[ref2.name/]_[ref.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and(res_[ref2.name/]_[ref.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[else]
	[for (attr : Attribute | role2.entity.attributes)]
	[if (i = 1)]
		joinCondition = res_[ref2.name/]_[ref.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and(res_[ref2.name/]_[ref.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[/if]
		res_[ref2.name/]_[ref.name/] = res_[ref2.name/]_[ref.name/].as("A").join(all, joinCondition).select("A.*").as(Encoders.bean([role2.entity.name.toUpperFirst()/]TDO.class));
}

Dataset<Row> res_row_[ref.name/]_[ref2.name/] = res_[role.getRelationShipType().name/]_[ref.name/]_[ref2.name/].join(res_[ref2.name/]_[ref.name/].withColumnRenamed("logEvents", "[role.getRelationShipType().name/]_logEvents"),
													res_[role.getRelationShipType().name/]_[ref.name/]_[ref2.name/].col("[getJavaAbsolutePath(ref2).toLowerFirst() /]_[ref2.sourceField->first().getPhysicalName()/]").equalTo(res_[ref2.name/]_[ref.name/].col("[getJavaAbsolutePath(ref2).toLowerFirst() /]_[ref2.targetField->first().getPhysicalName()/]")));
Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = res_row_[ref.name/]_[ref2.name/].select("[role.name.toLowerFirst()/].*").as(Encoders.bean([entity.name.toUpperFirst()/].class));
[elseif (db2 = joindb and db2.dbType.isRelational())]
//join between 2 SQL tables and a non-relational structure
// (A) (AB - B)
[role2.name/]_refilter = new MutableBoolean(false);
MutableBoolean [role.getRelationShipType().name/]_refilter = new MutableBoolean(false);
Dataset<[role2.getRelationShipType().name.toUpperFirst()/]TDO> res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/] = [role2.getRelationShipType().name.toLowerFirst()/]Service.get[role2.getRelationShipType().name.toUpperFirst()/]TDOListIn[table2.name/]And[jointable.name/]From[db2.name/]([role2.name/]_condition[if(role.getRelationShipType().attributes->size()>0)], [role.getRelationShipType().name/]_condition[/if], [role2.name/]_refilter[if(role.getRelationShipType().attributes->size()>0)], [role.getRelationShipType().name/]_refilter[/if]);
Dataset<[role.entity.name.toUpperFirst()/]TDO> res_[ref.name/]_[ref2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role.entity.name.toUpperFirst()/]TDOList[role.name.toUpperFirst()/]In[ref.name.toUpperFirst()/]In[table.name.toUpperFirst()/]From[table.getPhysicalSchema().name.toUpperFirst()/]([role.name/]_condition, [role.name/]_refilter);
if([role2.name/]_refilter.booleanValue()) {
	if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
	joinCondition = null;
	[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
	[for (attr : Attribute | role2.entity.identifier.attributes)]
	[if (i = 1)]
		joinCondition = res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and(res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[else]
	[for (attr : Attribute | role2.entity.attributes)]
	[if (i = 1)]
		joinCondition = res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and(res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].col("[role2.name.toLowerFirst()/].[attr.name/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[/if]
		res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/] = res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].as("A").join(all, joinCondition).select("A.*").as(Encoders.bean([role2.getRelationShipType().name.toUpperFirst()/]TDO.class));
} 
Dataset<Row> res_row_[ref2.name/]_[ref.name/] = res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].join(res_[ref.name/]_[ref2.name/].withColumnRenamed("logEvents", "[role2.getRelationShipType().name/]_logEvents"),
	res_[role2.getRelationShipType().name/]_[ref2.name/]_[ref.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.sourceField->first().getPhysicalName()/]").equalTo(res_[ref.name/]_[ref2.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.targetField->first().getPhysicalName()/]")));
Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = res_row_[ref2.name/]_[ref.name/].as(Encoders.bean([entity.name.toUpperFirst()/].class));
[else]
// (A) (AB) (B)  OR (A B) (AB) Join table is 'alone'
[role2.name/]_refilter = new MutableBoolean(false);
MutableBoolean [getJavaAbsolutePath(ref).toLowerFirst() /]_[role2.getRelationShipType().name/]_refilter = new MutableBoolean(false);
Dataset<[entity.name.toUpperFirst()/]TDO> [entity.name.toLowerFirst()/]TDO[ref.name/][role.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[entity.name.toUpperFirst()/]TDOList[role.name.toUpperFirst() /]In[ref.name.toUpperFirst()/]In[ref.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.targetField->first().getPhysicalSchema().name.toUpperFirst()/]([role.name/]_condition, [role.name/]_refilter);
Dataset<[role.getRelationShipType().name.toUpperFirst()/]TDO> [role.getRelationShipType().name.toLowerFirst()/]TDO[ref.name/]_[ref2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role.getRelationShipType().name.toUpperFirst()/]TDOListIn[role.ancestors(RelationshipType)->any(true).name.toUpperFirst()/]_[ref.name.toUpperFirst()/]_[ref2.name.toUpperFirst()/]In[ref.getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref.getPhysicalSchema().name.toUpperFirst()/]([if(role.getRelationShipType().attributes->size()>0)][role.getRelationShipType().name/]_condition, [getJavaAbsolutePath(ref).toLowerFirst() /]_[role.getRelationShipType().name/]_refilter[/if]);
Dataset<[role2.entity.name.toUpperFirst()/]TDO> [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role.getRelationShipType().name.toLowerFirst()/]Service.get[role2.entity.name.toUpperFirst()/]TDOList[role2.name.toUpperFirst() /]In[ref2.name.toUpperFirst()/]In[ref2.targetField->first().getAbstractPhysicalStructureNotEmbeddedObject().name.toUpperFirst() /]From[ref2.targetField->first().getPhysicalSchema().name.toUpperFirst()/]([role2.name/]_condition, [role2.name/]_refilter);
if([role2.name/]_refilter.booleanValue()) {
	if(all == null)
			all = new [role2.entity.name.toUpperFirst()/]ServiceImpl().get[role2.entity.name.toUpperFirst()/]List([role2.name/]_condition);
	joinCondition = null;
	[if (role2.entity.identifier.oclIsUndefined() = false and role2.entity.identifier.attributes->size() > 0)]
	[for (attr : Attribute | role2.entity.identifier.attributes)]
	[if (i = 1)]
		joinCondition = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[else]
	[for (attr : Attribute | role2.entity.attributes)]
	[if (i = 1)]
		joinCondition = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]"));
	[else]
		joinCondition = joinCondition.and([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[attr.name.toLowerFirst()/]").equalTo(all.col("[attr.name.toLowerFirst()/]")));
	[/if]
	[/for]
	[/if]
		[role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/] = [role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].as("A").join(all, joinCondition).select("A.*").as(Encoders.bean([role2.entity.name.toUpperFirst()/]TDO.class));
}
Dataset<Row> res_[ref.name/] = [entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].join([role.getRelationShipType().name.toLowerFirst()/]TDO[ref.name/]_[ref2.name/].withColumnRenamed("logEvents", "[role.getRelationShipType().name/]_logEvents"),
								[entity.name.toLowerFirst()/]TDO[ref.name/][role.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.targetField->first().getPhysicalName()/]").equalTo([role.getRelationShipType().name.toLowerFirst()/]TDO[ref.name/]_[ref2.name/].col("[getJavaAbsolutePath(ref).toLowerFirst() /]_[ref.sourceField->first().getPhysicalName()/]")));
res_[ref.name/] = res_[ref.name/].join([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/]
[for (attr : Attribute | role2.entity.attributes)]
	.withColumnRenamed("[attr.name.toLowerFirst() /]", "[role2.entity.name/]_[attr.name.toLowerFirst() /]")
[/for]
	.withColumnRenamed("logEvents", "[role2.entity.name/]_logEvents"),
	res_[ref.name/].col("[getJavaAbsolutePath(ref2).toLowerFirst() /]_[ref2.sourceField->first().getPhysicalName()/]").equalTo([role2.entity.name.toLowerFirst()/]TDO[ref.name/][role2.name/].col("[getJavaAbsolutePath(ref2).toLowerFirst() /]_[ref2.targetField->first().getPhysicalName()/]")));
Dataset<[entity.name.toUpperFirst()/]> res_[entity.name/]_[ref.name/] = res_[ref.name/].select([for (attr : Attribute | entity.attributes)] "[attr.name/]",[/for] "logEvents").as(Encoders.bean([entity.name.toUpperFirst()/].class));
[/if]
[if (entity.identifier.oclIsUndefined() = true)]
	logger.warn("Conceptual entity '[entity.name/]' does not have a declared identifier. Returned results may be inconsistent.");
	res_[entity.name/]_[ref.name/] = res_[entity.name/]_[ref.name/].dropDuplicates();
[else]
datasetsPOJO.add(res_[entity.name/]_[ref.name/].dropDuplicates(new String[ '[' /][ ']' /] {[if (entity.identifier.oclIsUndefined() = false)][for (attr : Attribute | entity.identifier.attributes) separator(',')]"[attr.name/]"[/for][/if]}));	
[/if]
[/let]
[/let]	
[/let]	
[/let]
[/let]
[/let]
[/template]
