[comment encoding = UTF-8 /]
[module generateSimpleInsertMethodsImpl('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[template public insertPOJOInRImpl(entityType: EntityType, roles : Collection(Role), conceptualSchema: ConceptualSchema)]{
	boolean inserted = false;
	// Insert in standalone structures
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/])|| inserted ;
	[/for]
	[/for]
	// Insert in structures containing double embedded role
	[for (struct: AbstractPhysicalStructure | getMappedComplexEmbeddedStructureOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
    inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for]) || inserted ;
	[/for]
	[/for]
	// Insert in descending structures
	[for (struct: AbstractPhysicalStructure | getDescendingOneLevelPhysicalStructuresOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for])|| inserted ;
	[/for]
	[/for]
	// Insert in ascending structures 
	[for (struct: AbstractPhysicalStructure | getAscendingPhysicalStructuresOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for])|| inserted ;
	[/for]
	[/for]
	// Insert in ref structures 
	[for (struct: AbstractPhysicalStructure | getRemainingRefStructureOfMappedMandatoryRoleOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for])|| inserted ;
	[/for]
	[/for]
	// Insert in ref structures mapped to opposite role of mandatory role  
	[for (struct: AbstractPhysicalStructure | getRemainingRefStructureMappedToOppositeOfMandatoryRoleOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for])|| inserted ;
	[/for]
	[/for]
	return inserted;
}[/template]

[template public insertPOJOImpl(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	// Insert into all mapped standalone AbstractPhysicalStructure 
	boolean inserted = false;
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
		inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/]) || inserted ;
	[/for]
	[/for]
	return inserted;
}[/template]

[template public generateCheckExistBeforeInsert(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	Condition<[entityType.name.toUpperFirst()/]Attribute> conditionID;
	String idvalue="";
	[for (attr : Attribute | entityType.identifier.attributes)]
		[if (i=1)]
	conditionID = Condition.simple([entityType.name.toUpperFirst()/]Attribute.[attr.name/], Operator.EQUALS, [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
	idvalue+=[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		[else]
	conditionID = Condition.and(conditionID, Condition.simple([entityType.name.toUpperFirst()/]Attribute.[attr.name/], Operator.EQUALS, [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()));
	idvalue+=","+[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		[/if]
	[/for]
	boolean entityExists=false;
	entityExists = !get[entityType.name.toUpperFirst() /]ListIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](conditionID,new MutableBoolean(false)).isEmpty();
			
[/template]

[template public insertInComplexEmbeddedStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	[generateDocument(entityType, struct.oclAsType(pml::Collection).fields, struct.oclAsType(pml::Collection).name,1,0)/]
	DBConnectionMgr.insertMany(List.of(doc[struct.name/]_1), "[struct.name/]", "[db.name/]");
	return true;
	
[/template]

[template public insertInDescendingStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment generate structType for Ent and for subsequent roles. Join them together in descending way. /]
	 // Implement Insert in descending complex struct
[comment]Insert using Spark[/comment]
[comment]	[generateStructField(entityType,struct.oclAsType(pml::Collection).fields, struct.oclAsType(pml::Collection).name,1,false)/]
	List<Row> listRows=new ArrayList<Row>();
	StructType struct = DataTypes.createStructType(listOfStructField[struct.oclAsType(pml::Collection).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(pml::Collection).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, struct, "mongo", "[struct.name/]", "[db.name/]");[/comment]
	Bson filter = new Document();
	Bson updateOp;
	[generateDocument(entityType, struct.oclAsType(pml::Collection).fields, struct.oclAsType(pml::Collection).name,1,0)/]
	[for (attr : Attribute | entityType.identifier.attributes)]
				[if (i=1)]
	filter = eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[else]
	filter = and(filter,eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
	[/for]
	updateOp = setOnInsert(doc[struct.name/]_1);
	DBConnectionMgr.upsertMany(filter, updateOp, "[struct.name/]", "[db.name/]");
	return true;
[/template]

[template public insertInAscendingStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	 // Implement Insert in ascending complex struct

	Bson filter= new Document();
	Bson updateOp;
	String addToSet;
	List<String> fieldName= new ArrayList();
	List<Bson> arrayFilterCond = new ArrayList();
	[let field : PhysicalField = getMappedPhysicalFieldOfRoleOfEntityWhereOppositeRoleIsMandatory(struct, entityType, entityType.getMappingRules())]
	[let role : Role = getMappedRoleOfPhysicalField(field)]
	[generateDocument(entityType,field.oclAsType(EmbeddedObject).fields, getPhysicalName(field),1,0)/]
	[if (field.eContainer(EmbeddedObject).oclIsUndefined()=false)]
	[ascendInStruct(field.eContainer(EmbeddedObject), getMappedRoleOfPhysicalField(field),struct, db, 0, entityType)/]
	fieldName.add("[getPhysicalName(field)/]");
	addToSet = String.join(".",fieldName);
	updateOp = addToSet(addToSet,doc[getPhysicalName(field)/]_1);
	DBConnectionMgr.upsertMany(filter, updateOp, arrayFilterCond, "[struct.name/]", "[db.name/]");
	[else] 
	// level 1 ascending
	[comment for each mandatory role object in list, in ascending structure we need to update the document. /]
				[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name/][getRelationShipType(role).name.toUpperFirst()/]){
				[else]
	[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name/][getRelationShipType(role).name.toUpperFirst()/];
				[/if]
			[for (attr : Attribute | role.entity.identifier.attributes)]
				[if (i=1)]
		filter = eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[else]
		filter = and(filter,eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
			[/for]
		updateOp = addToSet("[field.getPhysicalName()/]", doc[getPhysicalName(field)/]_1);
		DBConnectionMgr.upsertMany(filter, updateOp, "[struct.name/]", "[db.name/]");					
	[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	}
	[/if] 

	[/if]	
	[/let]
	[/let]
	return true;
[/template]

[template public ascendInStruct(embeddedObj : EmbeddedObject, role : Role, struct: AbstractPhysicalStructure, db:Database, level : Integer, roleEntityType : EntityType) ]
fieldName.add("[embeddedObj.getPhysicalName()/].$['['/][embeddedObj.getPhysicalName()/][']'/]");
[if (level>0)]
	[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	List<[role.entity.name.toUpperFirst()/]> [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [roleEntityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]List();
	[else]
		[role.entity.name.toUpperFirst()/] [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [roleEntityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name/]();
	[/if]
	if([role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]==null [if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]|| [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/].size()==0[/if]){
		logger.error("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[roleEntityType.name.toUpperFirst()/]");
		throw new PhysicalStructureException("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[roleEntityType.name.toUpperFirst()/]");
	}
[/if]
[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
List<String> idvalues = new ArrayList<>();
for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
	[for (attr : Attribute | role.entity.identifier.attributes)]
				[if (i=1)]
	idvalues.add([role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[else]
// TODO Handle multi attributes identifier
throw new UnsupportedOperationException("Multi component identifier not supported");
				[/if]
arrayFilterCond.add(in("[embeddedObj.getPhysicalName()/].[getPhysicalName(getMappedPhysicalField(attr, struct, db, attr.getMappingRules()))/]",idvalues));
	[/for]
}
[else]
[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
	[for (attr : Attribute | role.entity.identifier.attributes)]
				[if (i=1)]
arrayFilterCond.add(eq("[embeddedObj.getPhysicalName()/].[getPhysicalName(getMappedPhysicalField(attr, struct, db, attr.getMappingRules()))/]",[role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()));
				[else]
// TODO Handle multi attributes identifier
throw new UnsupportedOperationException("Multi component identifier not supported");
				[/if]
	[/for]
[/if]
[if (embeddedObj.eContainer(EmbeddedObject).oclIsUndefined()=false)]
[ascendInStruct(embeddedObj.eContainer(EmbeddedObject),getMappedRoleOfPhysicalField(embeddedObj), struct, db,level+1, role.entity)/]
[/if]
[/template]
	
[template public insertInRefStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	 // Implement Insert in structures with mandatory references
	List<String> columns = new ArrayList<>();
	List<Object> values = new ArrayList<>();
	List<List<Object>> rows = new ArrayList<>();
[comment]//TODO Docdb ref support. Only for relational reference for now[/comment]
[if (struct.oclIsTypeOf(Table))]
[comment]Normal fields [/comment]
[for (field : PhysicalField | struct.oclAsType(Table).columns)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
columns.add("[getPhysicalName(field)/]");
values.add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
columns.add("[getPhysicalName(field)/]");
values.add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[getPhysicalName(field)/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[getPhysicalName(field)/] += "[component.literal/]";
					[/if]
				[/for]
columns.add("[getPhysicalName(field)/]");
values.add(value_[getPhysicalName(field)/]);
			[/if]
		[/if]
	[/if]
[/for]
[comment]	Reference fields [/comment]
[if (isJoinStructureOfMappedMandatoryRoleOfEntity(entityType, struct, entityType.ancestors(Domainmodel)->first()))]
[comment]Join structure  A <- AB -> B[/comment]
	[for (ref : Reference | getRefOfPhysicalStructure(struct))]
		[let role : Role = getMappedRoleOfReference(ref)]
		[if (role.entity.name = entityType.name)]
	// Role in join structure 
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
	Object [entityType.name.toLowerFirst()/]Id = [entityType.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]();
	[/if]
	[/let]
	[/for]
	[for (ref : Reference | getRefOfPhysicalStructure(struct))]
		[let role : Role = getMappedRoleOfReference(ref)]
		[if (not (role.entity.name = entityType.name))]
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
		[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
		[else]
		[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
		[/if]
		values = new ArrayList<>();
		values.add([entityType.name.toLowerFirst()/]Id);
		values.add([role.entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
		rows.add(values);
		[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	}	
		[/if]
		[/if]
		[/let] 
	[/for]
[else]
[comment]// A -> B[/comment]
	[for (ref : Reference | getRefOfPhysicalStructure(struct))]
		[let role : Role = getMappedRoleOfReference(ref)]
	// Ref '[ref.name/]' mapped to role '[role.name/]'
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
	values.add([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
	rows.add(values);
	[/let]
	[/for]
[/if]
	DBConnectionMgr.insertInTable(columns, rows, "[struct.name/]", "[db.name/]");					
[/if]
	return true;
[/template]

[template public insertInRefStructureOfOppositeRole(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
 	// Entity '[entityType.name/]' reference in structure '[struct.name/]'
	[if (struct.oclIsTypeOf(Table))]
	List<String> columns = new ArrayList<>();
	List<Object> values = new ArrayList<>();
	String filtercolumn, filtervalue;
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
		[let roleref : Role = getMappedRoleOfReference(ref)]
			[if (entityType=getOppositeRoleInBinaryRel(roleref).entity)]
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
	values.add([getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
			[for (attr : Attribute | roleref.entity.identifier.attributes)]
						[if (i=1)]
	filtercolumn = "[getPhysicalName(getMappedPhysicalField(attr, struct, db, roleref.entity.getMappingRules()))/]";
	filtervalue = [roleref.name.toLowerFirst()/][getRelationShipType(roleref).name.toUpperFirst()/].get[attr.name.toUpperFirst()/]();
						[else]
	logger.error("To implement. Support of multi valued identifiers");
	throw new UnsupportedOperationException("Can't handle multi valued identifiers");
						[/if]
			[/for]
			[/if]
		[/let]
		[/for]
	DBConnectionMgr.updateInTable(filtercolumn, filtervalue, columns, values, "[struct.name/]", "[db.name/]");					
	return true;
	[else]
		[if (struct.oclIsTypeOf(pml::Collection))]
	Bson filter;
	Bson updateOp;
			[for (ref : Reference | getRefOfPhysicalStructure(struct))]
				[let roleref : Role = getMappedRoleOfReference(ref)]
				[if (entityType=getOppositeRoleInBinaryRel(roleref).entity)]
					[if (ref.sourceField->any(true).oclIsTypeOf(ArrayField))]
	updateOp = addToSet("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
					[else]
	updateOp = set("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
					[/if]
					[for (attr : Attribute | roleref.entity.identifier.attributes)]
						[if (i=1)]
	filter = eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[roleref.name.toLowerFirst()/][roleref.getRelationShipType().name.toUpperFirst()/].get[attr.name.toUpperFirst()/]());
						[else]
	filter = and(filter,eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[roleref.name.toLowerFirst()/][roleref.getRelationShipType().name.toUpperFirst()/].get[attr.name.toUpperFirst()/]());
						[/if]
					[/for]
	DBConnectionMgr.update(filter, updateOp, "[struct.name/]", "[db.name/]");
	return true;
				[/if]
				[/let]
			[/for]
		[else]
	return false;
		[/if]
	[/if]
	
[/template]

[template public insertInSQLDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType,struct.oclAsType(Table).columns, struct.oclAsType(Table).name,1,false)/]
	StructType structType = DataTypes.createStructType(listOfStructField[struct.oclAsType(Table).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(Table).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, structType, "jdbc", "[struct.name/]", "[db.name/]");
[/template]

[template public insertInMongoDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType, struct.oclAsType(pml::Collection).fields,struct.oclAsType(pml::Collection).name,1,false)/]
	StructType struct = DataTypes.createStructType(listOfStructField[struct.oclAsType(pml::Collection).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(pml::Collection).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, struct, "mongo", "[struct.name/]", "[db.name/]");
[/template]


[template public insertInRedisImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment insertEInREDIS(ENT e)
 /]
		String key="";
		boolean toAdd = false;
		[for (component : TerminalExpression | struct.oclAsType(KeyValuePair).key.pattern)]
						[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		key += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
							[/let]
						[else]
		key += "[component.literal/]";
						[/if]
		[/for]
		[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(pml::KVComplexField))]
			[comment Generate value for hash structure /]
		List<Tuple2<String,String>> hash = new ArrayList<>();
			[for (field : PhysicalField | struct.oclAsType(KeyValuePair).value.oclAsType(KVComplexField).fields)]
		toAdd = false;
		String fieldname_[getPhysicalName(field)/]="[getPhysicalName(field)/]";
		String value_[getPhysicalName(field)/]="";
				[if (field.oclIsTypeOf(ShortField))]
						[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
							[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
							[/if]
						[/let] 
				[/if]
				[if (field.oclIsTypeOf(LongField))]
				[comment LongField with only one component and is BracketsField /]
					[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
						[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
							[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
							[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
							[/if]
							[/let] 
						[/let]
					[else]
						[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
							[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
							[comment LongField is composed of component, therefore can only be StringType /]
							[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
								[if (component.oclIsTypeOf(BracketsField))]
									[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
		else
			value_[getPhysicalName(field)/] += "";
									[/let]
								[else]
		value_[getPhysicalName(field)/] += "[component.literal/]";
								[/if]
							[/for]
						[/if]
					[/if]
				[/if]
		[comment When value is null for a field in the hash we dont add it to the hash.  /]
		// When value is null for a field in the hash we dont add it to the hash.
		if(toAdd)
			hash.add(new Tuple2<String,String>(fieldname_[getPhysicalName(field)/],value_[getPhysicalName(field)/]));
			[/for]
		SparkConnectionMgr.writeKeyValueHash(key,hash, "[db.name/]");
		[else]
		[comment Generate value for simple string value /]
		
		String value="";
			[let field : PhysicalField = struct.oclAsType(KeyValuePair).value]
			[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(ShortField))]
					[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
						[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
						[/if]
					[/let] 
			[/if]
			[if (field.oclIsTypeOf(LongField))]
			[comment LongField with only one component and is BracketsField /]
				[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
					[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
						[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
						[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
						[/if]
						[/let] 
					[/let]
				[else]
					[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
						[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
						[comment LongField is composed of component, therefore can only be StringType /]
						[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
							[if (component.oclIsTypeOf(BracketsField))]
								[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
		else
			value+= "";
								[/let]
							[else]
		value += "[component.literal/]";
							[/if]
						[/for]
					[/if]
				[/if]
			[/if]
			[/let]
		[comment  No addition of key value pari when the value is null./]
		//No addition of key value pair when the value is null.
		if(toAdd)
			SparkConnectionMgr.writeKeyValue(key,value,"[db.name/]");
		[/if]
[/template]

[template public generateDocument(entityType : EntityType, fields : Collection(PhysicalField), objectName : String, level : Integer, embeddedRoleLevel : Integer)]
Document doc[objectName/]_[level/] = new Document();
[for (field : PhysicalField | fields)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
doc[objectName/]_[level/].append("[getPhysicalName(field)/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
doc[objectName/]_[level/].append("[getPhysicalName(field)/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[objectName/]_[getPhysicalName(field)/]_[level/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += "[component.literal/]";
					[/if]
				[/for]
doc[objectName/]_[level/].append("[getPhysicalName(field)/]",value_[objectName/]_[getPhysicalName(field)/]_[level/]);
			[/if]
		[/if]
	[/if]
[comment]Verify if field mapped to reference[/comment]
[comment]	Reference fields [/comment]
[comment]// A -> B[/comment]
	[for (ref : Reference | getReferenceOfPhysicalField(field))]
		[let role : Role = getMappedRoleOfReference(ref)]
		[if (isMandatoryRole(role))]
// Ref '[ref.name/]' mapped to mandatory role '[role.name/]'
			[if (embeddedRoleLevel>0)]
	if([entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]()!=null){
doc[objectName/]_[level/].append("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]().get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
	}else{
		logger.error("Physical Structure contains attribute or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
		throw new PhysicalStructureException("Physical Structure contains attribute or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
	}
			[else]
doc[objectName/]_[level/].append("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
			[/if]
		[/if]
	[/let]
	[/for]
[comment][/comment]
	[if (field.oclIsTypeOf(EmbeddedObject) and field.isMappedToRole(entityType.getMappingRules())=false)]
// Embedded structure [field.getPhysicalName()/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
	[generateDocument(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel)/]
				[if (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ONE_MANY) or (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ZERO_MANY)]
	List<Document> array[field.getPhysicalName()/]_[level/] = new ArrayList();
	array[field.getPhysicalName()/]_[level/].add(doc_[field.getPhysicalName()/]_[level+1/]);
	doc[objectName/]_[level/].append("[field.getPhysicalName()/]", array[field.getPhysicalName()/]_[level/]);
				[else]
	doc[objectName/]_[level/].append("[field.getPhysicalName()/]", doc[field.getPhysicalName()/]_[level+1/]);
				[/if]
		[/if]
	[else]
	[let role : Role = getMappedRoleOfPhysicalField(field)]
		[if (role.isMandatoryRole())]
// field '[field.getPhysicalName()/]' is mapped to mandatory role '[role.name/]' with opposite role of type '[role.getOppositeRoleInBinaryRel().entity.name/]'
			[if(embeddedRoleLevel>0)]
				[if (role.isCardinalityMaxN())]
	List<[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]> [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]List();
				[else]
		[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]();
				[/if]
	if([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]==null [if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]|| [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/].size()==0[/if]){
		logger.error("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
		throw new PhysicalStructureException("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
	}
			[/if]
			[if (role.isCardinalityMaxN())]
	List<Document> array[field.getPhysicalName()/]_[level/] = new ArrayList();
		for([role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] : [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
			[generateDocument(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel+1)/]
			array[field.getPhysicalName()/]_[level/].add(doc[field.getPhysicalName()/]_[level+1/]);
		}
	doc[objectName/]_[level/].append("[field.getPhysicalName()/]", array[field.getPhysicalName()/]_[level/]);
			[else]
		[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] = [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
		[generateDocument(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel+1)/]
		doc[objectName/]_[level/].append("[field.getPhysicalName()/]", doc[field.getPhysicalName()/]_[level+1/]);
			[/if]
		[/if]
	[/let]
	[/if]
[/for]
[/template]

[template public generateStructField(entityType : EntityType, fields : Collection(PhysicalField), objectName : String, level : Integer, inEmbeddedRole : Boolean)]
[if (not inEmbeddedRole)]
List<Object> values[objectName/]_[level/] = new ArrayList<>();
List<StructField> listOfStructField[objectName/]_[level/] = new ArrayList<StructField>();
[/if]
[for (field : PhysicalField | fields)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
if(!listOfStructField[objectName/]_[level/].contains(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true)))
	listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[objectName/]_[getPhysicalName(field)/]_[level/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += "[component.literal/]";
					[/if]
				[/for]
if(!listOfStructField[objectName/]_[level/].contains(DataTypes.createStructField("[getPhysicalName(field)/]",DataTypes.StringType, true)))
	listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",DataTypes.StringType, true));
values[objectName/]_[level/].add(value_[objectName/]_[getPhysicalName(field)/]_[level/]);
			[/if]
		[/if]
	[/if]
[comment]Verify if field mapped to reference[/comment]
[comment]	Reference fields [/comment]
[comment]// A -> B[/comment]
	[for (ref : Reference | getReferenceOfPhysicalField(field))]
		[let role : Role = getMappedRoleOfReference(ref)]
		[if (isMandatoryRole(role))]
// Ref '[ref.name/]' mapped to mandatory role '[role.name/]'
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",DataTypes.StringType, true));
values[objectName/]_[level/].add([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
		[/if]
	[/let]
	[/for]
[comment][/comment]
	[if (field.oclIsTypeOf(EmbeddedObject) and field.isMappedToRole(entityType.getMappingRules())=false)]
	Object row_value_[field.getPhysicalName()/]_[level+1/] = null;
// Embedded structure [field.getPhysicalName()/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
				[generateStructField(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,false)/]
		StructType structType_[objectName/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
				[if (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ONE_MANY) or (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ZERO_MANY)]
		ArrayType array[field.getPhysicalName()/]_[level/] = DataTypes.createArrayType(structType_[objectName/]_[level/]);
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",array[field.getPhysicalName()/]_[level/],true));
		row_value_[field.getPhysicalName()/]_[level+1/] = Arrays.asList(RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray()));
				[else]
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",structType_[objectName/]_[level/], true));
		row_value_[field.getPhysicalName()/]_[level+1/] = RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray());
				[/if]
		values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
		[/if]
	[else]
	[let role : Role = getMappedRoleOfPhysicalField(field)]
	[if (role.isMandatoryRole())]
// field '[field.getPhysicalName()/]' is mapped to mandatory role '[role.name/]' with opposite role of type '[role.getOppositeRoleInBinaryRel().entity.name/]'
	List<Object> values[field.getPhysicalName()/]_[level+1/] = new ArrayList<>();
	List<StructField> listOfStructField[field.getPhysicalName()/]_[level+1/] = new ArrayList<StructField>();
	if([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]!=null){
	[if (role.isCardinalityMaxN())]
	List<Row> row_value_[field.getPhysicalName()/]_[level+1/] = new ArrayList<>();
		for([role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] : [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
			values[field.getPhysicalName()/]_[level+1/].clear();
			[generateStructField(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1, true)/]
			row_value_[field.getPhysicalName()/]_[level+1/].add(RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray()));
		}
	StructType structType_[field.getPhysicalName()/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
	ArrayType array[field.getPhysicalName()/]_[level/] = DataTypes.createArrayType(structType_[field.getPhysicalName()/]_[level/]);
	listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",array[field.getPhysicalName()/]_[level/],true));
	values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
	[else]
		Row row_value_[field.getPhysicalName()/]_[level+1/];
		[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] = [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
		[generateStructField(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,true)/]
		StructType structType_[field.getPhysicalName()/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",structType_[field.getPhysicalName()/]_[level/],true));
		row_value_[field.getPhysicalName()/]_[level+1/] = RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray());
		values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
	[/if]
	}
	[/if]
	[/let]
	[/if]
[/for]
[/template]

