[comment encoding = UTF-8 /]
[module generateSimpleInsertMethodsImpl('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[template public implMethod1(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	//TODO
}[/template]

[template public insertPOJOImpl(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	// Insert into all mapped AbstractPhysicalStructure 
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
		insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/]);
	[/for]
	[/for]
}[/template]

[template public implMethod3(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	//TODO
}[/template]

	
[template public insertInSQLDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment insertEInRELTABLE(ENT e)
For each PhysicalFIeld get the mapped conceptual attribute of ENT
 /]
{
	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType,struct.oclAsType(Table).columns, struct.oclAsType(Table).name,1)/]
	StructType structType = DataTypes.createStructType(listOfStructField[struct.oclAsType(Table).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(Table).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, structType, "jdbc", "[struct.name/]", "[db.name/]");
}
[/template]


[template public insertInMongoDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
{
	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType, struct.oclAsType(pml::Collection).fields,struct.oclAsType(pml::Collection).name,1)/]
	StructType struct = DataTypes.createStructType(listOfStructField[struct.oclAsType(pml::Collection).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(pml::Collection).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, struct, "mongo", "[struct.name/]", "[db.name/]");
}
[/template]

[template public generateStructField(entityType : EntityType, fields : Collection(PhysicalField), objectName : String, level : Integer)]
List<Object> values[objectName/]_[level/] = new ArrayList<>();
List<StructField> listOfStructField[objectName/]_[level/] = new ArrayList<StructField>();
[for (field : PhysicalField | fields)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[objectName/]_[getPhysicalName(field)/]_[level/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += "[component.literal/]";
					[/if]
				[/for]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",DataTypes.StringType, true));
values[objectName/]_[level/].add(value_[objectName/]_[getPhysicalName(field)/]_[level/]);
			[/if]
		[/if]
	[/if]
	[if (field.oclIsTypeOf(EmbeddedObject) and field.isMappedToRole(entityType.getMappingRules())=false)]
	Object row_value_[field.getPhysicalName()/]_[level+1/] = null;
// Embedded structure [field.getPhysicalName()/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
				[generateStructField(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1)/]
		StructType structType_[objectName/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
				[if (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ONE_MANY) or (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ZERO_MANY)]
		ArrayType array[field.getPhysicalName()/]_[level/] = DataTypes.createArrayType(structType_[objectName/]_[level/]);
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",array[field.getPhysicalName()/]_[level/],true));
		row_value_[field.getPhysicalName()/]_[level+1/] = Arrays.asList(RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray()));
				[else]
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",structType_[objectName/]_[level/], true));
		row_value_[field.getPhysicalName()/]_[level+1/] = RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray());
				[/if]
		values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
		[/if]
	[/if]
[/for]
[/template]

[query private getMappedAttributesInStructure(ent: EntityType, struct : AbstractPhysicalStructure, db : Database, rules: MappingRules) : Collection(Attribute) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getMappedAttributes(be.unamur.polystore.pml.EntityType, be.unamur.polystore.pml.AbstractPhysicalStructure, be.unamur.polystore.pml.Database, be.unamur.polystore.pml.MappingRules)', Sequence{ent, struct, db, rules})
/]


[query private getRefOfPhysicalStructure(struct : AbstractPhysicalStructure) : Collection(Reference) =  
	invoke('be.unamur.polystore.acceleo.main.utils.MappingRuleService', 'getRefOfPhysicalStructure(be.unamur.polystore.pml.AbstractPhysicalStructure)', Sequence{struct})
/]
