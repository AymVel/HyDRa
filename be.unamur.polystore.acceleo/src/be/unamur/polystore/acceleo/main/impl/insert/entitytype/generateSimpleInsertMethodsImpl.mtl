[comment encoding = UTF-8 /]
[module generateSimpleInsertMethodsImpl('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[template public insertPOJOInRImpl(entityType: EntityType, roles : Collection(Role), conceptualSchema: ConceptualSchema)]{
	// Insert in structures containing double embedded role
	[for (struct: AbstractPhysicalStructure | getMappedComplexEmbeddedStructureOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
    insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for]);
	[/for]
	[/for]
	// Insert in descending structures
	[for (struct: AbstractPhysicalStructure | getDescendingOneLevelPhysicalStructuresOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for]);
	[/for]
	[/for]
	// Insert in ascending structures 
	[for (struct: AbstractPhysicalStructure | getAscendingPhysicalStructuresOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for]);
	[/for]
	[/for]
	// Insert in join structures 
	[for (struct: AbstractPhysicalStructure | getJoinStructureOfMappedMandatoryRoleOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for]);
	[/for]
	[/for]
	// Insert in standalone structures
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/]);
	[/for]
	[/for]
}[/template]

[template public insertPOJOImpl(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	// Insert into all mapped AbstractPhysicalStructure 
	boolean inserted = false;
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
		inserted = insertStandalone[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/]) || inserted ;
	[/for]
	[/for]
	return inserted;
}[/template]

[template public generateCheckExistBeforeInsert(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	Condition<[entityType.name.toUpperFirst()/]Attribute> conditionID;
	String idvalue="";
	[for (attr : Attribute | entityType.identifier.attributes)]
		[if (i=1)]
	conditionID = Condition.simple([entityType.name.toUpperFirst()/]Attribute.[attr.name/], Operator.EQUALS, [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
	idvalue+=[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		[else]
	conditionID = Condition.and(conditionID, Condition.simple([entityType.name.toUpperFirst()/]Attribute.[attr.name/], Operator.EQUALS, [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()));
	idvalue+=","+[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		[/if]
	[/for]
	boolean entityExists=false;
	entityExists = !get[entityType.name.toUpperFirst() /]ListIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](conditionID,new MutableBoolean(false)).isEmpty();
			
[/template]

[template public insertInComplexEmbeddedStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	// Implement Insert In Complex Embedded struct. So we must check that POJO attributes are set.
	/*if(r_reviewed_movieMovieReview._getCharacterList().isEmpty() || r_reviewed_movieMovieReview._getCharacterList() == null){
				logger.error("Attribute entity type Actor in r_reviewed_movieMovieReview Movie object must be set in order to correctly insert in collection ['['/]ReviewCol[']'/]");
				throw new PhysicalStructureException("Attribute entity type Actor in r_reviewed_movieMovieReview Movie object must be set in order to correctly insert in collection ['['/]ReviewCol[']'/]");
			}
	*/
	return false;
	
[/template]

[template public insertInComplexStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	 // Implement Insert In other complex struct
			return false;
[/template]
	
[template public insertInSQLDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment insertEInRELTABLE(ENT e)
For each PhysicalFIeld get the mapped conceptual attribute of ENT
 /]
	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType,struct.oclAsType(Table).columns, struct.oclAsType(Table).name,1)/]
	StructType structType = DataTypes.createStructType(listOfStructField[struct.oclAsType(Table).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(Table).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, structType, "jdbc", "[struct.name/]", "[db.name/]");
[/template]

[template public insertInRedisImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment insertEInREDIS(ENT e)
 /]
		String key="";
		boolean toAdd = false;
		[for (component : TerminalExpression | struct.oclAsType(KeyValuePair).key.pattern)]
						[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		key += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
							[/let]
						[else]
		key += "[component.literal/]";
						[/if]
		[/for]
		[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(pml::KVComplexField))]
			[comment Generate value for hash structure /]
		List<Tuple2<String,String>> hash = new ArrayList<>();
			[for (field : PhysicalField | struct.oclAsType(KeyValuePair).value.oclAsType(KVComplexField).fields)]
		toAdd = false;
		String fieldname_[getPhysicalName(field)/]="[getPhysicalName(field)/]";
		String value_[getPhysicalName(field)/]="";
				[if (field.oclIsTypeOf(ShortField))]
						[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
							[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
							[/if]
						[/let] 
				[/if]
				[if (field.oclIsTypeOf(LongField))]
				[comment LongField with only one component and is BracketsField /]
					[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
						[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
							[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
							[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
							[/if]
							[/let] 
						[/let]
					[else]
						[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
							[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
							[comment LongField is composed of component, therefore can only be StringType /]
							[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
								[if (component.oclIsTypeOf(BracketsField))]
									[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
		else
			value_[getPhysicalName(field)/] += "";
									[/let]
								[else]
		value_[getPhysicalName(field)/] += "[component.literal/]";
								[/if]
							[/for]
						[/if]
					[/if]
				[/if]
		[comment When value is null for a field in the hash we dont add it to the hash.  /]
		// When value is null for a field in the hash we dont add it to the hash.
		if(toAdd)
			hash.add(new Tuple2<String,String>(fieldname_[getPhysicalName(field)/],value_[getPhysicalName(field)/]));
			[/for]
		SparkConnectionMgr.writeKeyValueHash(key,hash, "[db.name/]");
		[else]
		[comment Generate value for simple string value /]
		
		String value="";
			[let field : PhysicalField = struct.oclAsType(KeyValuePair).value]
			[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(ShortField))]
					[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
						[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
						[/if]
					[/let] 
			[/if]
			[if (field.oclIsTypeOf(LongField))]
			[comment LongField with only one component and is BracketsField /]
				[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
					[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
						[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
						[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
						[/if]
						[/let] 
					[/let]
				[else]
					[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
						[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
						[comment LongField is composed of component, therefore can only be StringType /]
						[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
							[if (component.oclIsTypeOf(BracketsField))]
								[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
		else
			value+= "";
								[/let]
							[else]
		value += "[component.literal/]";
							[/if]
						[/for]
					[/if]
				[/if]
			[/if]
			[/let]
		[comment  No addition of key value pari when the value is null./]
		//No addition of key value pair when the value is null.
		if(toAdd)
			SparkConnectionMgr.writeKeyValue(key,value,"[db.name/]");
		[/if]
[/template]

[template public insertInMongoDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType, struct.oclAsType(pml::Collection).fields,struct.oclAsType(pml::Collection).name,1)/]
	StructType struct = DataTypes.createStructType(listOfStructField[struct.oclAsType(pml::Collection).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(pml::Collection).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, struct, "mongo", "[struct.name/]", "[db.name/]");
[/template]

[template public generateStructField(entityType : EntityType, fields : Collection(PhysicalField), objectName : String, level : Integer)]
List<Object> values[objectName/]_[level/] = new ArrayList<>();
List<StructField> listOfStructField[objectName/]_[level/] = new ArrayList<StructField>();
[for (field : PhysicalField | fields)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[objectName/]_[getPhysicalName(field)/]_[level/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += "[component.literal/]";
					[/if]
				[/for]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",DataTypes.StringType, true));
values[objectName/]_[level/].add(value_[objectName/]_[getPhysicalName(field)/]_[level/]);
			[/if]
		[/if]
	[/if]
	[if (field.oclIsTypeOf(EmbeddedObject) and field.isMappedToRole(entityType.getMappingRules())=false)]
	Object row_value_[field.getPhysicalName()/]_[level+1/] = null;
// Embedded structure [field.getPhysicalName()/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
				[generateStructField(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1)/]
		StructType structType_[objectName/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
				[if (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ONE_MANY) or (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ZERO_MANY)]
		ArrayType array[field.getPhysicalName()/]_[level/] = DataTypes.createArrayType(structType_[objectName/]_[level/]);
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",array[field.getPhysicalName()/]_[level/],true));
		row_value_[field.getPhysicalName()/]_[level+1/] = Arrays.asList(RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray()));
				[else]
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",structType_[objectName/]_[level/], true));
		row_value_[field.getPhysicalName()/]_[level+1/] = RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray());
				[/if]
		values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
		[/if]
	[/if]
[/for]
[/template]

[query private getMappedAttributesInStructure(ent: EntityType, struct : AbstractPhysicalStructure, db : Database, rules: MappingRules) : Collection(Attribute) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getMappedAttributes(be.unamur.polystore.pml.EntityType, be.unamur.polystore.pml.AbstractPhysicalStructure, be.unamur.polystore.pml.Database, be.unamur.polystore.pml.MappingRules)', Sequence{ent, struct, db, rules})
/]


[query private getRefOfPhysicalStructure(struct : AbstractPhysicalStructure) : Collection(Reference) =  
	invoke('be.unamur.polystore.acceleo.main.utils.MappingRuleService', 'getRefOfPhysicalStructure(be.unamur.polystore.pml.AbstractPhysicalStructure)', Sequence{struct})
/]
