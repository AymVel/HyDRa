grammar be.unamur.polystore.Pml with org.eclipse.xtext.common.Terminals

generate pml "http://www.unamur.be/polystore/Pml"

Domainmodel:
    conceptualSchema=ConceptualSchema & physicalSchema=AbstractPhysicalSchema & mappingRules= MappingRules & databases = Databases
    
;

ConceptualSchema :
	'conceptual' 'schema' name=ID '{'
		(entities+=EntityType)+ & (relationships+=RelationshipType)*
	'}'
;

EntityType returns EntityType:
	'entity' 'type' name=ID '{'
		(attributes+=Attribute (','attributes+=Attribute)*)?
		'}'
;
 
RelationshipType:
	'relationship' 'type' name=ID '{'
	(roles+=Role (','roles+=Role)*)+
	(','attributes+=Attribute)*
'}'
;

Role:
	name = ID ('['cardinality=Cardinality']') ':' entity=[EntityType]
;

Attribute:
	name=ID ':' (type=DataType)
;

enum Cardinality returns Cardinality:
				ZERO_ONE = '0-1' | ONE = '1' | ZERO_MANY = '0-N' | ONE_MANY = '1-N';

QualifiedName:
    ID ('.' ID)*
;

AbstractPhysicalSchema:
	{AbstractPhysicalSchema} 'physical' 'schemas' '{' 
		(kvschemas+=KeyValueSchema* & documentschemas+= DocumentSchema* & relationalschemas+=RelationalSchema* & graphschemas+= GraphSchema* & columnschemas += ColumnSchema*)
	'}'
;

DocumentSchema:
	'document' 'schema' name=ID (':' databases+=[Database] (','databases+=[Database])*)?'{'
	(collections+=Collection)*
'}'
;

Collection:
	'collection' name=ID '{'
		 'fields' '{'
		(fields+=PhysicalField (',' fields+=PhysicalField)*)?
	'}'
		('references' '{'references+=Reference*'}' )?
	'}'
;

Reference:
	name=ID ':' sourceField=[PhysicalField|QualifiedName] '->' targetField=[PhysicalField|QualifiedName]
;


PhysicalField returns PhysicalField:
	ShortField | EmbeddedObject | BracketsField | LongField
;

PhysicalRelationalField returns PhysicalField:
	ShortField | LongField
;

LongField:
	physicalName=ID ':''['name=ID']'
;

EmbeddedObject:
	name=ID '['cardinality=Cardinality']'('{'
		(fields+=PhysicalField (',' fields+=PhysicalField)*)?
	'}')?
;

ShortField :
	name=ID
;


ColumnSchema:
	'column' 'schema' name=ID (':' databases+=[Database] (','databases+=[Database])*)? '{'
		tables+=(TableColumnDB)* ('references' '{'references+=Reference*'}' )?
	'}'
;

TableColumnDB:
	'table' name=ID '{'
		rowkey=Rowkey ('columnfamilies' '{'columnfamilies+=ColumnFamily*'}')
	'}'
;

ColumnFamily:
	name=ID '{'
		columns+=ShortField (','columns+= ShortField)*
	'}'
;

Rowkey:
	{Rowkey} 'rowkey' '{'
	 fields+=ShortField*
	 '}'
;


GraphSchema:
	'graph' 'schema' name=ID (':' databases+=[Database] (','databases+=[Database])*)?'{'
		(nodes+=Node)* (edges+=Edge)* ('references' '{'references+=Reference*'}' )?
	'}'
;

Node:
	'Node' name=ID '{'
		fields+=PhysicalField (','fields+=PhysicalField)*
	'}'
;

Edge:
	'Edge' name=ID '{'
		sourceNode=[Node] '->' targetNode = [Node] (',' fields+=ShortField)*
	'}' 	
;

RelationalSchema:
	'relational' 'schema' name=ID (':' databases+=[Database] (','databases+=[Database])*)?'{'
		tables+=Table*
	'}'
;

Table:
	'table' name=ID '{'
		'columns' '{'
			(columns+=PhysicalRelationalField (',' columns+=PhysicalRelationalField)*)?
			'}'
		('references' '{'references+=Reference*'}')? 
		//Identifier and index section
	'}'
;

AbstractPhysicalStructure:
	Table | Collection | Node | TableColumnDB | Edge
;

KeyValueSchema:
	'key' 'value' 'schema' name=ID (':' databases+=[Database] (','databases+=[Database])*)?'{'
		kvpairs+=KeyValuePair
		('references' '{'references+=Reference*'}')? 
'}'
;

KeyValuePair:
	'kvpairs' name=ID '{'
		'key' ':' key=Key ','
		'value' ':' value=Value
	'}'
;

Key:
	 stringParts+=STRING* & fields+=BracketsField*  // Comment intercaller les variables
;

Value:
	Object | BracketsField
;

Object:
	'{'
		fields+=PhysicalField (',' fields+=PhysicalField)*
	'}'
;

/*Used for key value */
BracketsField:
	'['name=ID']'
;

MappingRules:
	{MappingRules} 'mapping' 'rules' '{'
		(mappingRules+=AbstractMappingRule (','mappingRules+=AbstractMappingRule)*)?
	'}'
;


AbstractMappingRule:
	EntityMappingRule | RoleMappingRule
;

RoleMappingRule:
	roleConceptual=[Role|QualifiedName]
	'->'
	 physicalStructure=[AbstractPhysicalStructure|QualifiedName]'('(physicalFields+=[PhysicalField|QualifiedName] (','physicalFields+=[PhysicalField|QualifiedName])*)?')'
;

EntityMappingRule:
	(entityConceptual=[EntityType|QualifiedName]'('(attributesConceptual+=[Attribute|QualifiedName] (','attributesConceptual+=[Attribute|QualifiedName])*)?')'
	'->'
	 physicalStructure=[AbstractPhysicalStructure|QualifiedName]'('(physicalFields+=[PhysicalField|QualifiedName] (','physicalFields+=[PhysicalField|QualifiedName])*)?')')
;

Databases :
	{Databases} 'databases' '{'
		(databases+=Database)*
	'}'
;

enum DatabaseType :
	MARIADB = 'mariadb' | SQLITE = 'sqlite' | REDIS ='redis' | CASSANDRA = 'cassandra' | HBASE = 'hbase' | MONGODB = 'mongodb' | NEO4J = 'neo4j'
;

Database :
	dbType=DatabaseType name=ID '{'
		(('host'':'host=STRING)  & ('port'':'port= INT) & ('dbname'':'databaseName=STRING)? & ('login'':'login=STRING)? & ('password'':'password=STRING)?)
	'}'
;

DataType returns DataType:
	IntType | 
	BigintType | 
	StringType | 
	TextType | 
	PointType | 
	PolygonType | 
	BoolType | 
	FloatType | 
	BlobType | 
	DateType | 
	DatetimeType
	;

IntType returns IntType:
	{IntType}
	'int'
	;

BigintType returns BigintType:
	{BigintType}
	'bigint'
	;

StringType returns StringType:
	{StringType}
	'string' ('[' maxSize=INT ']')?
	;

TextType returns TextType:
	{TextType}
	'text'
	;

PointType returns PointType:
	{PointType}
	'point'
	;

PolygonType returns PolygonType:
	{PolygonType}
	'polygon'
	;

BoolType returns BoolType:
	{BoolType}
	'bool'
	;

FloatType returns FloatType:
	{FloatType}
	'float'
	;

BlobType returns BlobType:
	{BlobType}
	'blob'
	;


DateType returns DateType:
	{DateType}
	'date'
	;

DatetimeType returns DatetimeType:
	{DatetimeType}
	'datetime'
	;