[comment encoding = UTF-8 /]
[module generateSelectKeyValue('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[template public generateSelectKeyValue(ent : EntityType, struct : KeyValuePair, db : Database)]
[generateSelectKeyValue(ent , struct, db, Sequence{})/]
[/template]

[template public generateSelectKeyValue(ent : EntityType, struct : KeyValuePair, db : Database, references : Sequence(Sequence(OclAny)))]
[generateSelectKeyValue(ent.name.toUpperFirst(), ent.attributes, struct, db, references)/]
[/template]

[template public generateSelectKeyValue(rel : RelationshipType, struct : KeyValuePair, db : Database)]
[generateSelectKeyValue(rel , struct, db, Sequence{})/]
[/template]

[template public generateSelectKeyValue(rel : RelationshipType, struct : KeyValuePair, db : Database, references : Sequence(Sequence(OclAny)))]
[generateSelectKeyValue(rel.name.toUpperFirst(), rel.attributes, struct, db, references)/]
[/template]

[template public generateSelectKeyValue(pojoName : String, attributes : Collection(Attribute), struct : KeyValuePair, db : Database, references : Sequence(Sequence(OclAny)))]
	// As we cannot filter on the values in a Redis DB, we always put the refilterflag to true.
	refilterFlag.setValue(true);
	// Build the key pattern
	//  - If the condition attribute is in the key pattern, replace by the value. Only if operator is EQUALS.
	//  - Replace all other fields of key pattern by a '*' 
	String keypattern= "";
	String finalKeypattern;
	List<String> fieldsListInKey = new ArrayList<>();
	[for (expr : TerminalExpression | struct.key.pattern)]
		[if (expr.oclIsTypeOf(pml::BracketsField) = true)]
	[comment TODO here find a way to determine that the BracketField is indeed mapped to a POJO attribute and replace by condition value instead of '*'/]
	keypattern=keypattern.concat("*");
	fieldsListInKey.add("[expr.oclAsType(pml::BracketsField).name/]");
		[else]
	keypattern=keypattern.concat("[expr.literal/]");
		[/if]
	[/for]
		
	// Find the type of query to perform in order to retrieve a Dataset<Row>
	// Based on the type of the value. Is a it a simple string or a hash or a list... 
	Dataset<Row> rows;
	[if struct.value.oclIsTypeOf(pml::KVComplexField)=false]
	[comment Retrieve data and build POJO based on Dataset<Row> containing only 'key' and 'value' attributes. /]
	rows = SparkConnectionMgr.getRowsFromKeyValue("[db.name/]",keypattern);
	// Transform to POJO. Based on Row containing (String key, String value)
	finalKeypattern = keypattern;
	Dataset<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]> res = rows.map((MapFunction<Row, [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>) r -> {
				[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if] [pojoName.toLowerFirst() /]_res = new [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]();
				Integer groupindex = null;
				String regex = null;
				String value = null;
				Pattern p, pattern = null;
				Matcher m, match = null;

				boolean matches = false;
				[for (attr : Attribute | attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, struct.ancestors(Domainmodel)->first().mappingRules)]
				[if (field <> null)]
				[if (not (field.ancestors(Key) -> size() = 0))]
				[comment Attribute mapped in a Key /]
				// attribute [ '[' /][pojoName/].[attr.name.toUpperFirst() /][ ']' /]
				// Attribute mapped in a key.
				String key = r.getAs("key");
				regex = finalKeypattern.replaceAll("\\*","(.*)");
				groupindex = fieldsListInKey.indexOf("[field.getPhysicalName()/]")+1;
				if(groupindex==null) {
					logger.warn("Attribute of '[pojoName /]' mapped physical field '[field.getPhysicalName()/]' found in key but can't get index in build keypattern '{}'.", finalKeypattern);
				}
				p = Pattern.compile(regex);
				m = p.matcher(key);
				matches = m.find();
				String [attr.name.toLowerFirst()/] = null;
				if(matches) {
					[attr.name.toLowerFirst()/] = m.group(groupindex.intValue());
				} else {
					logger.warn("Cannot retrieve value for [pojoName /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
				[else]
				[comment Attribute mapped in value part of KVPair/]
				// attribute [ '[' /][pojoName /].[attr.name.toUpperFirst() /][ ']' /]
				// Attribute mapped in value part.
				value = r.getAs("value");
				[if (field.ancestors(LongField) -> size() = 0)]
				[comment shortField or bracketfield/]
				[generateJavaType(attr.type)/] [attr.name.toLowerFirst()/] = [generateParsingFunctionJavaType(attr.type,'value')/];
				[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([attr.name.toLowerFirst()/]);
				[else]
				[comment LongField /]
				regex = "[getJavaRegexFromLongField(field.ancestors(LongField) -> first().oclAsType(LongField)) /]";
				groupindex = [getPositionInLongField(field, field.ancestors(LongField) -> first().oclAsType(LongField))/];
				if(groupindex == null) {
					logger.warn("Cannot retrieve value for [pojoName /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				p = Pattern.compile(regex);
				m = p.matcher(value);
				matches = m.find();
				String [attr.name.toLowerFirst()/] = null;
				if(matches) {
					[attr.name.toLowerFirst()/] = m.group(groupindex.intValue());
				} else {
					logger.warn("Cannot retrieve value for [pojoName/][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName/].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
				[/if]
				[/if]
				[/if]
				[/let]
				[/for]
				
				[for (pair : Sequence(OclAny) | references)]
				[let ref : Reference = pair->at(1)]
				[let refFields : Sequence(PhysicalField) = pair->at(2)]
					[for (refField : PhysicalField | refFields)]
						[comment For refField /]
					[if (refField.oclIsUndefined()=false)]
				//Checking that reference field '[refField.getPhysicalName()/]' is mapped in Key
				if(fieldsListInKey.contains("[refField.getPhysicalName()/]")){
					//Retrieving reference field '[refField.getPhysicalName()/]' in Key
					groupindex = fieldsListInKey.indexOf("[refField.getPhysicalName()/]")+1;
					if(groupindex==null) {
						logger.warn("Attribute '[pojoName /]' mapped physical field '[refField.getPhysicalName()/]' found in key but can't get index in build keypattern '{}'.", finalKeypattern);
					}
					p = Pattern.compile(regex);
					m = p.matcher(key);
					matches = m.find();
					String [refField.getPhysicalName()/] = null;
					if(matches) {
					[refField.getPhysicalName()/] = m.group(groupindex.intValue());
					} else {
					logger.warn("Cannot retrieve value '[refField.getPhysicalName()/]'. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for '[refField.getPhysicalName()/]' attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					}
					[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([refField.getPhysicalName()/]);
				}else {
					//Retrieving reference field '[refField.getPhysicalName()/]' in Value
					value = r.getAs("value");
					[if (refField.ancestors(LongField) -> size() = 0)]
					[comment shortField or bracketfield/]
					[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /]);
					[else]
					[comment LongField /]
					regex = "[getJavaRegexFromLongField(refField.ancestors(LongField) -> first().oclAsType(LongField)) /]";
					groupindex = [getPositionInLongField(refField, refField.ancestors(LongField) -> first().oclAsType(LongField))/];
					if(groupindex == null) {
						logger.warn("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
						[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[refField.getPhysicalName() /] . Probably due to an ambiguous regex.");
					}
					p = Pattern.compile(regex);
					m = p.matcher(value);
					matches = m.find();
					String [refField.getPhysicalName() /]_ref = null;
					if(matches) {
						[refField.getPhysicalName() /]_ref = m.group(groupindex.intValue());
					} else {
						logger.warn("Cannot retrieve value for [pojoName/][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
						[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					}
					[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([refField.getPhysicalName() /]_ref);
					[/if]
					}
					[/if]
					[/for]
				[/let]
				[/let]
				[/for]
					
				return [pojoName.toLowerFirst() /]_res;
			}, Encoders.bean([pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if].class));
	return res;
	[else]
		[comment Retrieve Dataset<Row> containing field of hashes. TODO other Redis dataTypes. /]
		// TODO only handles 'hash' for now
	rows = SparkConnectionMgr.getRowsFromKeyValueHashes("[db.name/]",keypattern);
	finalKeypattern = keypattern;
	Dataset<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]> res = rows.map((MapFunction<Row, [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>) r -> {
				[pojoName/][if (references->size() > 0)][getTDOLiteral('') /][/if] [pojoName.toLowerFirst() /]_res = new [pojoName/][if (references->size() > 0)][getTDOLiteral('') /][/if]();
				Integer groupindex = null;
				String regex = null;
				String value = null;
				Pattern p, pattern = null;
				Matcher m, match = null;
				boolean matches = false;
				[for (attr : Attribute | attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, struct.ancestors(Domainmodel)->first().mappingRules)]
				[if (field <> null)]
				[if (not (field.ancestors(Key) -> size() = 0))]
				[comment Attribute mapped in a Key /]
				// attribute [ '[' /][pojoName/].[attr.name.toUpperFirst() /][ ']' /]
				// Attribute mapped in a key.
				String key = r.getAs("id");
				[comment Spark Redis automatically strips leading character if the pattern provided contains a single '*' at the end. /]
				// Spark Redis automatically strips leading character if the pattern provided contains a single '*' at the end.				
				pattern = Pattern.compile("\\*");
		        match = pattern.matcher(finalKeypattern);
		        if(match.results().count()==1){
					[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type,'key')/]);
				}else{
					regex = finalKeypattern.replaceAll("\\*","(.*)");
					groupindex = fieldsListInKey.indexOf("[field.getPhysicalName()/]")+1;
					if(groupindex==null) {
						logger.warn("Attribute '[pojoName /]' mapped physical field '[field.getPhysicalName()/]' found in key but can't get index in build keypattern '{}'.", finalKeypattern);
					}
					p = Pattern.compile(regex);
					m = p.matcher(key);
					matches = m.find();
					String [attr.name.toLowerFirst()/] = null;
					if(matches) {
						[attr.name.toLowerFirst()/] = m.group(groupindex.intValue());
					} else {
						logger.warn("Cannot retrieve value for [pojoName/][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
						[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					}
					[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
				}
				[else]
				// attribute [ '[' /][pojoName/].[attr.name.toUpperFirst() /][ ']' /]
				[if (field.ancestors(LongField) -> size() = 0)]
				[comment shortField or bracketfield/]
				[generateJavaType(attr.type)/] [attr.name.toLowerFirst()/] = [generateParsingFunctionJavaType(attr.type, 'r.getAs("' + getPhysicalName(field) + '")' )/];
				[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([attr.name.toLowerFirst()/]);
				[else]
				[comment LongField /]
				regex = "[getJavaRegexFromLongField(field.ancestors(LongField) -> first().oclAsType(LongField)) /]";
				groupindex = [getPositionInLongField(field, field.ancestors(LongField) -> first().oclAsType(LongField))/];
				if(groupindex == null) {
					logger.warn("Cannot retrieve value for [pojoName /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				value = r.getAs("[field.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
				p = Pattern.compile(regex);
				m = p.matcher(value);
				matches = m.find();
				String [attr.name.toLowerFirst()/] = null;
				if(matches) {
					[attr.name.toLowerFirst()/] = m.group(groupindex.intValue());
				} else {
					logger.warn("Cannot retrieve value for [pojoName /][attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
				}
				[pojoName.toLowerFirst() /]_res.set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
				[/if]
				[/if]
				[/if]
				[/let]
				[/for]
				[comment For refField /]
				[for (pair : Sequence(OclAny) | references)]
				[let ref : Reference = pair->at(1)]
				[let refFields : Sequence(PhysicalField) = pair->at(2)]
				[for (refField : PhysicalField | refFields)]
				[if (refField.oclIsUndefined() = false)]
				key = r.getAs("id");
				//Checking that reference field '[refField.getPhysicalName()/]' is mapped in Key
				if(fieldsListInKey.contains("[refField.getPhysicalName()/]")){
					//Retrieving reference field '[refField.getPhysicalName()/]' in Key
					// Spark Redis automatically strips leading character if the pattern provided contains a single '*' at the end.				
					Pattern pattern_[refField.getPhysicalName()/] = Pattern.compile("\\*");
			        Matcher match_[refField.getPhysicalName()/] = pattern_[refField.getPhysicalName()/].matcher(finalKeypattern);
			        if(match_[refField.getPhysicalName()/].results().count()==1){
						[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /](key);
					}else{
					groupindex = fieldsListInKey.indexOf("[refField.getPhysicalName()/]")+1;
					if(groupindex==null) {
						logger.warn("Attribute '[pojoName /]' mapped physical field '[refField.getPhysicalName()/]' found in key but can't get index in build keypattern '{}'.", finalKeypattern);
					}
					p = Pattern.compile(regex);
					m = p.matcher(key);
					matches = m.find();
					String [refField.getPhysicalName()/] = null;
					if(matches) {
					[refField.getPhysicalName()/] = m.group(groupindex.intValue());
					} else {
					logger.warn("Cannot retrieve value '[refField.getPhysicalName()/]'. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for '[refField.getPhysicalName()/]' attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					}
					[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([refField.getPhysicalName()/]);
					}
				}else{
				// Get reference column in value [ '[' /][refField.getPhysicalName()/] [ ']' /] for reference [ '[' /][ref.name/][ ']' /]
				[if (refField.ancestors(LongField) -> size() = 0)]
				[comment shortField or bracketfield/]
				String [getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /] = r.getAs("[getPhysicalName(refField) /]");
				[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /]);
				[else]
				[comment LongField /]
				regex = "[getJavaRegexFromLongField(refField.ancestors(LongField) -> first().oclAsType(LongField)) /]";
				groupIndex = [getPositionInLongField(refField, refField.ancestors(LongField) -> first().oclAsType(LongField))/];
				if(groupIndex == null) {
					logger.warn("Cannot retrieve value for [pojoName /].[refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for BLABLABLA. Probably due to an ambiguous regex.");
				}
				value = r.getAs("[refField.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
				p = Pattern.compile(regex);
				m = p.matcher(value);
				matches = m.find();
				String [getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /] = null;
				if(matches) {
					[getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /] = m.group(groupIndex.intValue());
				} else {
					logger.warn("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
					[pojoName.toLowerFirst() /]_res.addLogEvent("Cannot retrieve value for BLABLABLA. Probably due to an ambiguous regex.");
				}
				[pojoName.toLowerFirst() /]_res.set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /]);
				[/if]
				}
				[/if]
				[/for]
				[/let]
				[/let]
				[/for]

					return [pojoName.toLowerFirst() /]_res;
			}, Encoders.bean([pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if].class));
	[comment Contrary to other dbs, we perform the filter here, as in case of role based selection, at least one of the retrieved TDO datasets must be filtered in order to join. But refilterFlag is not available at the caller level
	And to not refactor everything we do it here. As the refilterFlag is always true. /]
	if(refilterFlag.booleanValue())
		res = res.filter((FilterFunction<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>) r -> condition == null || condition.evaluate(r));
	[comment 
	 This drop duplicates is necessary when readin data from a key value db, with key structures such as PRODUCT:id:REVIEW:reviewid . /]
	res=res.dropDuplicates();
	return res;
	[/if]
[/template]

[template public getTDOLiteral(o : OclAny)][if (o.oclIsUndefined() = false)]TDO[/if][/template]